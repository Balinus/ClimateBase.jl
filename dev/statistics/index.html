<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Statistics · ClimateBase</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Quicksand|Montserrat|Source+Code+Pro|Lora&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimateBase</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../netcdf/">NetCDF IO</a></li><li class="is-active"><a class="tocitem" href>Statistics</a><ul class="internal"><li><a class="tocitem" href="#Temporal"><span>Temporal</span></a></li><li><a class="tocitem" href="#Spatial"><span>Spatial</span></a></li><li><a class="tocitem" href="#General-aggregation"><span>General aggregation</span></a></li><li><a class="tocitem" href="#Missing-data"><span>Missing data</span></a></li></ul></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../advanced/">Advanced functionality</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Statistics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Statistics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/master/docs/src/statistics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Statistics"><a class="docs-heading-anchor" href="#Statistics">Statistics</a><a id="Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Statistics" title="Permalink"></a></h1><h2 id="Temporal"><a class="docs-heading-anchor" href="#Temporal">Temporal</a><a id="Temporal-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal" title="Permalink"></a></h2><p>Functions related with the <code>Time</code> dimension.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.timemean" href="#ClimateBase.timemean"><code>ClimateBase.timemean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">timemean(A::ClimArray [, w]) = timeagg(mean, A, w)</code></pre><p>Temporal average of <code>A</code>, see <a href="#ClimateBase.timeagg"><code>timeagg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L250-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.timeagg" href="#ClimateBase.timeagg"><code>ClimateBase.timeagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">timeagg(f, A::ClimArray, W = nothing)</code></pre><p>Perform a proper temporal aggregation of the function <code>f</code> (e.g. <code>mean, std</code>) on <code>A</code> where:</p><ul><li>Only full year spans of <code>A</code> are included, see <a href="#ClimateBase.maxyearspan"><code>maxyearspan</code></a> (because most processes are affected by yearly cycle, and averaging over an uneven number of cycles typically results in artifacts)</li><li>Each month in <code>A</code> is weighted with its length in days (for monthly sampled data)</li></ul><p>If you don&#39;t want these features, just do <a href="#ClimateBase.dropagg"><code>dropagg</code></a><code>(f, A, Time, W)</code>. This is also done in the case where the time sampling is unknown.</p><p><code>W</code> are possible statistical weights that are used in conjuction to the temporal weighting, to weight each time point differently. If they are not a vector (a weight for each time point), then they have to be a dimensional array of same dimensional layout as <code>A</code> (a weight for each data point).</p><p>See also <a href="#ClimateBase.monthlyagg"><code>monthlyagg</code></a>, <a href="#ClimateBase.yearlyagg"><code>yearlyagg</code></a>, <a href="#ClimateBase.seasonalyagg"><code>seasonalyagg</code></a>.</p><pre><code class="nohighlight hljs">timeagg(f, t::Vector, x::Vector, w = nothing)</code></pre><p>Same as above, but for arbitrary vector <code>x</code> accompanied by time vector <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L257-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.monthlyagg" href="#ClimateBase.monthlyagg"><code>ClimateBase.monthlyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">monthlyagg(A::ClimArray, f = mean; mday = 15) -&gt; B</code></pre><p>Create a new array where the temporal information has been aggregated into months using the function <code>f</code>. The dates of the new array always have day number of <code>mday</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L370-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.yearlyagg" href="#ClimateBase.yearlyagg"><code>ClimateBase.yearlyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">yearlyagg(A::ClimArray, f = mean) -&gt; B</code></pre><p>Create a new array where the temporal information has been aggregated into years using the function <code>f</code>. By convention, the dates of the new array always have month and day number of <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L385-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.seasonalyagg" href="#ClimateBase.seasonalyagg"><code>ClimateBase.seasonalyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seasonalyagg(A::ClimArray, f = mean) -&gt; B</code></pre><p>Create a new array where the temporal information has been aggregated into seasons using the function <code>f</code>. By convention, seasons are represented as Dates spaced 3-months apart, where only the months December, March, June and September are used to specify the date, with day 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L437-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.temporalrange" href="#ClimateBase.temporalrange"><code>ClimateBase.temporalrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">temporalrange(A::ClimArray, f = Dates.month) → r
temporalrange(t::AbstractVector{&lt;:TimeType}}, f = Dates.month) → r</code></pre><p>Return a vector of ranges so that each range of indices are values of <code>t</code> that belong in either the same month, year, day, or season, depending on <code>f</code>. <code>f</code> can take the values: <code>Dates.year, Dates.month, Dates.day</code> or <code>season</code> (all are functions).</p><p>Used in e.g. <a href="#ClimateBase.monthlyagg"><code>monthlyagg</code></a>, <a href="#ClimateBase.yearlyagg"><code>yearlyagg</code></a> or <a href="#ClimateBase.seasonalyagg"><code>seasonalyagg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L410-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.maxyearspan" href="#ClimateBase.maxyearspan"><code>ClimateBase.maxyearspan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maxyearspan(A::ClimArray) = maxyearspan(dims(A, Time))
maxyearspan(t::Vector{&lt;:DateTime}) → i</code></pre><p>Find the maximum index <code>i</code> of <code>t</code> so that <code>t[1:i]</code> covers exact(*) multiples of years.</p><p>(*) For monthly spaced data <code>i</code> is a multiple of <code>12</code> while for daily data we find the largest possible multiple of <code>DAYS_IN_ORBIT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L77-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.temporal_sampling" href="#ClimateBase.temporal_sampling"><code>ClimateBase.temporal_sampling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">temporal_sampling(x) → symbol</code></pre><p>Return the temporal sampling type of <code>x</code>, which is either an array of <code>Date</code>s or a dimensional array (with <code>Time</code> dimension).</p><p>Possible return values are:</p><ul><li><code>:hourly</code>, where the temporal difference between successive entries is exactly 1 hour.</li><li><code>:daily</code>, where the temporal difference between successive entries is exactly 1 day.</li><li><code>:monthly</code>, where all dates have the same day, but different month.</li><li><code>:yearly</code>, where all dates have the same month and day, but different year.</li><li><code>:other</code>, which means that <code>x</code> doesn&#39;t fall to any of the above categories.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L19-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.realtime_days" href="#ClimateBase.realtime_days"><code>ClimateBase.realtime_days</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">realtime_days(t::AbstractVector{&lt;:TimeType}, T = Float32)</code></pre><p>Convert the given <em>sequential</em> date time vector <code>t</code> in a vector in a format of &quot;real time&quot;, where time is represented by real numbers, increasing cumulatively, as is the case when representing a timeseries <code>x(t)</code>. As only differences matter in this form, the returned vector always starts from 0. The measurement unit of time here is days.</p><p>For temporal sampling less than daily return <code>realtime_milliseconds(t) ./ (24*60*60*1000)</code>.</p><p>Example:</p><pre><code class="language-juliarepl hljs">julia&gt; t = Date(2004):Month(1):Date(2004, 6)
Date(&quot;2004-01-01&quot;):Month(1):Date(&quot;2004-06-01&quot;)

julia&gt; realtime_days(t)
6-element Vector{Float32}:
   0.0
  29.0
  60.0
  90.0
 121.0
 151.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L156-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.realtime_milliseconds" href="#ClimateBase.realtime_milliseconds"><code>ClimateBase.realtime_milliseconds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">realtime_milliseconds(t::AbstractArray{&lt;:TimeType}, T = Float64)</code></pre><p>Similar with <a href="#ClimateBase.realtime_days"><code>realtime_days</code></a>, but now the measurement unit is millisecond. For extra accuracy, direct differences in <code>t</code> are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.seasonality" href="#ClimateBase.seasonality"><code>ClimateBase.seasonality</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seasonality(t, x; y0 = year(t[1])) → dates, vals</code></pre><p>Calculate the &quot;seasonality&quot; of a vector <code>x</code> defined with respect to a datetime vector <code>t</code> and return <code>dates, vals</code>. <code>dates</code> are all unique dates present in <code>t</code> <em>disregarding the year</em> (so only the month and day are compared). The <code>dates</code> have as year entry <code>y0</code>. <code>vals</code> is a vector of vectors, where <code>vals[i]</code> are all the values of <code>x</code> that have day and month same as <code>dates[i]</code>. The elements of <code>vals</code> are sorted as encountered in <code>x</code>.</p><p>Typically one is interested in <code>mean.(vals)</code>, which actually is the seasonality, and <code>std.(vals)</code> which is the interannual variability at each date.</p><pre><code class="nohighlight hljs">seasonality(A::ClimArray) → dates, vals</code></pre><p>If given a <code>ClimArray</code>, then the array must have only one dimension (time).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L489-L503">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.sametimespan" href="#ClimateBase.sametimespan"><code>ClimateBase.sametimespan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sametimespan(Xs) → Ys</code></pre><p>Given a container of <code>ClimArray</code>s, return the same <code>ClimArray</code>s but now accessed in the <code>Time</code> dimension so that they all have span the same time interval. Also works for dictionaries with values <code>ClimArray</code>s.</p><p><code>sametimespan</code> takes into consideration the temporal sampling of the arrays for better accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/temporal.jl#L212-L220">source</a></section></article><h2 id="Spatial"><a class="docs-heading-anchor" href="#Spatial">Spatial</a><a id="Spatial-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial" title="Permalink"></a></h2><p>All functions in this section work for both types of space, see <a href="#Types-of-spatial-information">Types of spatial information</a>.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.zonalmean" href="#ClimateBase.zonalmean"><code>ClimateBase.zonalmean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zonalmean(A::ClimArray [, W])</code></pre><p>Return the zonal mean of <code>A</code>. Works for both <a href="#ClimateBase.OrthogonalSpace"><code>OrthogonalSpace</code></a> as well as <a href="#ClimateBase.CoordinateSpace"><code>CoordinateSpace</code></a>. Optionally provide statistical weights <code>W</code>. These can be the same <code>size</code> as <code>A</code> or only having the same latitude structure as <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/spatial.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.latmean" href="#ClimateBase.latmean"><code>ClimateBase.latmean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">latmean(A::ClimArray)</code></pre><p>Return the latitude-mean <code>A</code> (mean across dimension <code>Lat</code>). This function properly weights by the cosine of the latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/spatial.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spacemean" href="#ClimateBase.spacemean"><code>ClimateBase.spacemean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spacemean(A::ClimArray [, W]) = spaceagg(mean, A, W)</code></pre><p>Average <code>A</code> over its spatial coordinates. Optionally provide statistical weights in <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/spatial.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spaceagg" href="#ClimateBase.spaceagg"><code>ClimateBase.spaceagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spaceagg(f, A::ClimArray, W = nothing)</code></pre><p>Aggregate <code>A</code> using function <code>f</code> (e.g. <code>mean, std</code>) over all available space (i.e. longitude and latitude) of <code>A</code>, weighting every part of <code>A</code> by its spatial area.</p><p><code>W</code> can be extra weights, to weight each spatial point with. <code>W</code> can either be a <code>ClimArray</code> with same spatial information as <code>A</code>, or having exactly same dimensions as <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/spatial.jl#L137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.hemispheric_means" href="#ClimateBase.hemispheric_means"><code>ClimateBase.hemispheric_means</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hemispheric_means(A [,W]) → nh, sh</code></pre><p>Return the (proper) averages of <code>A</code> over the northern and southern hemispheres. Notice that this function explicitly does both zonal as well as meridional averaging. Use <a href="#ClimateBase.hemispheric_functions"><code>hemispheric_functions</code></a> to just split <code>A</code> into two hemispheres.</p><p>Optionally provide weights <code>W</code> that need to have the same structure as <a href="#ClimateBase.spaceagg"><code>spaceagg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/spatial.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.hemispheric_functions" href="#ClimateBase.hemispheric_functions"><code>ClimateBase.hemispheric_functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hemispheric_functions(A::ClimArray) → north, south</code></pre><p>Return two arrays <code>north, south</code>, by splitting <code>A</code> to its northern and southern hemispheres, appropriately translating the latitudes of <code>south</code> so that both arrays have the same latitudinal dimension (and thus can be compared and do opperations between them).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/spatial.jl#L199-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.tropics_extratropics" href="#ClimateBase.tropics_extratropics"><code>ClimateBase.tropics_extratropics</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tropics_extratropics(A::ClimArray; lower_lat=30, higher_lat=90) → tropics, extratropics</code></pre><p>Separate the given array into two arrays: one having latitudes ℓ ∈ [-lower<em>lat, +lower</em>lat], and one having [-higher<em>lat:-lower</em>lat, lower<em>lat:higher</em>lat].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/spatial.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.lonlatfirst" href="#ClimateBase.lonlatfirst"><code>ClimateBase.lonlatfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lonlatfirst(A::ClimArray, args...) → B</code></pre><p>Permute the dimensions of <code>A</code> to make a new array <code>B</code> that has first dimension longitude, second dimension latitude, with the remaining dimensions of <code>A</code> following (useful for most plotting functions). Optional extra dimensions can be given as <code>args...</code>, specifying a specific order for the remaining dimensions.</p><p>Example:</p><pre><code class="language-julia hljs">B = lonlatfirst(A)
C = lonlatfirst(A, Time)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/spatial.jl#L30-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.longitude_circshift" href="#ClimateBase.longitude_circshift"><code>ClimateBase.longitude_circshift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">longitude_circshift(X::ClimArray [, l]; wrap = true) → Y::ClimArray</code></pre><p>Perform the same action as <code>Base.circshift</code>, but only for the longitudinal dimension of <code>X</code> with shift <code>l</code>. If <code>wrap = true</code> the longitudes are wrapped to (-180, 180) degrees using the modulo operation.</p><p>If <code>l</code> is not given, it is as much as necessary so that all longitudes &gt; 180 are wrapped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/spatial.jl#L67-L75">source</a></section></article><h3 id="Types-of-spatial-information"><a class="docs-heading-anchor" href="#Types-of-spatial-information">Types of spatial information</a><a id="Types-of-spatial-information-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-spatial-information" title="Permalink"></a></h3><p>Spatial information (excluding height/pressure dimensions) in ClimateBase.jl exists in one of two forms:</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.OrthogonalSpace" href="#ClimateBase.OrthogonalSpace"><code>ClimateBase.OrthogonalSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Space information is represented by two orthogonal dimensions <code>Lon, Lat</code>, one being longitude and the other being latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/core/coredefs.jl#L81-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.CoordinateSpace" href="#ClimateBase.CoordinateSpace"><code>ClimateBase.CoordinateSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Space information is represented by a single dimension <code>Coord</code>, whose elements are coordinates, i.e. 2-element <code>SVector(longitude, latitude)</code>. Each coordinate represents the center of an arbitrary polygon in space. The actual limits of each polygon are not included in the dimension for performance reasons.</p><p>In statistical functions such as <a href="#ClimateBase.spaceagg"><code>spaceagg</code></a>, it is assumed that entry of the coordinates covers <strong>an equal amount of area</strong>. If this is not the case, you can simply provide an additional weights vector which would correspond to the area covered.</p><p>This dimension also allows indexing by latitude ranges, e.g. you can do</p><pre><code class="language-julia hljs">A # some `ClimArray` with a `Coord` dimension
A[Coord(Lat(-30..30)))]</code></pre><p>Most functions of ClimateBase.jl implicitly assume that the coordinates are sorted by latidude. You can achieve this with the following code:</p><pre><code class="language-julia hljs">A # some `ClimArray` with a `Coord` dimension
coords = gnv(dims(A, Coord))
si = sortperm(coords; by = reverse)
A = A[Coord(si)]</code></pre><p><strong>This is done automatically by <a href="../netcdf/#ClimateBase.ncread"><code>ncread</code></a>.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/core/coredefs.jl#L87-L112">source</a></section></article><p>ClimateBase.jl works with either type of spatial coordinate system. Therefore, physically inspired averaging functions, like <a href="#ClimateBase.spacemean"><code>spacemean</code></a> or <a href="#ClimateBase.zonalmean"><code>zonalmean</code></a>, work for both types of spatial coordinates. In addition, the function <code>spatialidxs</code> returns an iterator over the spatial coordinates of the data, and works for both types (grid or equal-area):</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spatialidxs" href="#ClimateBase.spatialidxs"><code>ClimateBase.spatialidxs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spatialidxs(A::ClimArray) → idxs</code></pre><p>Return an iterable that can be used to access all spatial points of <code>A</code> with the syntax</p><pre><code class="language-julia hljs">idxs = spatialidxs(A)
for i in idxs
    slice_at_give_space_point = A[i...]
end</code></pre><p>Works for all types of space (<code>...</code> is necessary because <code>i</code> is a <code>Tuple</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/physical_dimensions/spatial.jl#L12-L22">source</a></section></article><p><a href="../netcdf/#ClimateBase.ncread"><code>ncread</code></a> tries to automatically deduce the correct space type and create the appropriate dimension.</p><h2 id="General-aggregation"><a class="docs-heading-anchor" href="#General-aggregation">General aggregation</a><a id="General-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#General-aggregation" title="Permalink"></a></h2><p>The physical averages of the previous section are done by taking advantage of a general aggregation syntax, which works with any aggregating function like <code>mean, sum, std</code>, etc.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.dropagg" href="#ClimateBase.dropagg"><code>ClimateBase.dropagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dropagg(f, A::ClimArray, d [, W])</code></pre><p>Apply statistics/aggregating function <code>f</code> (e.g. <code>sum</code> or <code>mean</code>) on array <code>A</code> across dimension(s) <code>d</code> and drop the corresponding dimension(s) from the result (Julia inherently keeps singleton dimensions).</p><p>If <code>A</code> is one dimensional, <code>dropagg</code> will return the single number of applying <code>f(A)</code>.</p><p>Optionally you can provide statistical weights in the form of a <code>W::ClimArray</code>. <code>W</code> must either have same size as <code>A</code> or have only one dimension and satisfy <code>length(W) == length(dims(A, d))</code> (i.e., a weight for each value of the dimension <code>d</code>). The latter case can only work when <code>d</code> is a single dimension. See also  <a href="#ClimateBase.missing_weights"><code>missing_weights</code></a> for (properly) dealing with data that have <code>missing</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/core/aggregation.jl#L61-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.collapse" href="#ClimateBase.collapse"><code>ClimateBase.collapse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collapse(f, A, dim)</code></pre><p>Reduce <code>A</code> towards dimension <code>dim</code> using the collapsing function <code>f</code> (e.g. <code>mean</code>). This means that <code>f</code> is applied across all other dimensions of <code>A</code>, each of which are subsequently dropped, leaving only the collapsed result of <code>A</code> vs. the remaining dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/core/aggregation.jl#L107-L112">source</a></section></article><h2 id="Missing-data"><a class="docs-heading-anchor" href="#Missing-data">Missing data</a><a id="Missing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-data" title="Permalink"></a></h2><p>When loading an array with <a href="../netcdf/#ClimateBase.ncread"><code>ncread</code></a>, the values of the return array may contain missing values if the actual data contain missing values according to the CF-standards. In other packages or other programming languages these missing values are handled &quot;internally&quot; and e.g. in statistical operations like <code>mean</code>, the statistics explicitly skip over missing values. For example this is a typical workflow of creating an array, assigning <code>missing</code> to all values of an array over land, and then taking the <code>mean</code> of the array, which would be the &quot;mean over ocean&quot;.</p><p>ClimateBase.jl <em>does not</em> follow this approach for two reasons: 1) it does not comply with <a href="https://docs.julialang.org/en/v1/manual/missing/">Julia&#39;s <code>missing</code> propagation logic</a>, 2) using proper statistical weights gives more power to the user. As you have already seen in the documentation strings of e.g. <a href="#ClimateBase.timeagg"><code>timeagg</code></a>, <a href="#ClimateBase.spaceagg"><code>spaceagg</code></a> or <a href="#ClimateBase.dropagg"><code>dropagg</code></a>, you can provide explicit statistical weights of various forms. This gives you more power, because in the case of <code>missing</code> your statistical weights can only be 0 (missing value) or 1 (non-missing value). As an example, &quot;pixel&quot; of your spatial grid will have ambiguous values if it is not 100% covered by ocean, and to do a <em>proper</em> average over ocean you should instead provide weights <code>W</code> whose value is quite simply the ocean fraction of each pixel.</p><p>But what if you already have an array with <code>missing</code> values and you want to do what was described in the beginning, e.g. average by skipping the missings? Do not worry, we have you covered! Use the function <a href="#ClimateBase.missing_weights"><code>missing_weights</code></a>! See also <a href="../advanced/#ClimateBase.sinusoidal_continuation"><code>sinusoidal_continuation</code></a> if the missing values are only in a subset of your temporal coverage.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.missing_weights" href="#ClimateBase.missing_weights"><code>ClimateBase.missing_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">missing_weights(A::ClimArray, val = missing_val(A)) → B, W</code></pre><p>Generate a new array <code>B</code> with values like <code>A</code>, but with <code>A</code>&#39;s <code>missing</code> values replaced with <code>val</code>. Also generate an array of weights, which has the value 0 when <code>A</code> had <code>missing</code>, and the value <code>1</code> otherwise.</p><p>The output of this function should be used in conjunction with any of ClimateBase.jl aggregating functions like <code>spacemean, timemean, ...</code>, when your data have <code>missing</code> values which you want to <em>completely skip</em> during the aggregation process.</p><p>This function returns <code>A, nothing</code> if <code>A</code> has no <code>missing</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/core/aggregation.jl#L17-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.missing_val" href="#ClimateBase.missing_val"><code>ClimateBase.missing_val</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">missing_val(A)</code></pre><p>Return the value that represents &quot;missing&quot; data in <code>A</code>, according to <code>A</code>&#39;s metadata. If <code>A</code> does not have the <code>_FillValue</code> metadata, return 0 instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8fc582520fad340d7eb41aa349871e39711f448c/src/core/aggregation.jl#L42-L46">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../netcdf/">« NetCDF IO</a><a class="docs-footer-nextpage" href="../plotting/">Plotting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 22 February 2022 16:27">Tuesday 22 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
