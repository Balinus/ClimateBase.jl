<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · ClimateBase</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Quicksand|Montserrat|Source+Code+Pro|Lora&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ClimateBase</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#ClimArray:-the-core-data-structure"><span><code>ClimArray</code>: the core data structure</span></a></li><li><a class="tocitem" href="#NetCDF-IO"><span>NetCDF IO</span></a></li><li><a class="tocitem" href="#Temporal"><span>Temporal</span></a></li><li><a class="tocitem" href="#Spatial"><span>Spatial</span></a></li><li><a class="tocitem" href="#General-aggregation"><span>General aggregation</span></a></li><li><a class="tocitem" href="#Timeseries-Analysis"><span>Timeseries Analysis</span></a></li><li><a class="tocitem" href="#Climate-quantities"><span>Climate quantities</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Ensemble-types"><span>Ensemble types</span></a></li><li><a class="tocitem" href="#Crash-course-to-DimensionalData.jl"><span>Crash-course to DimensionalData.jl</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p><code>ClimateBase</code> is a Julia package offering basic functionality for analyzing data that are typically in the form used by climate sciences. These data are dimensional &amp; spatiotemporal but the corresponding dimensions all need special handling. For example the most common dimensions are longitude, latitude and time.</p><ul><li>longitude is by definition a periodic dimension</li><li>latitude is a linear dimension. However because the coordinate system most often used in climate sciences is a grid of longitude × latitude (in equal degrees) the area element of space depends on latitude and this needs to be taken into account.</li><li>time is a linear dimension <em>in principle</em>, but its values are <code>&lt;: AbstractDateTime</code> instead of <code>&lt;: Real</code>. The human calendar (where these values come from) is periodic but each period may not correspond to the same physical time, and this also needs to be taken into account.</li></ul><p><code>ClimateBase</code> is structured to deal with these intricacies, and in addition offer several functionalities commonly used, and sought after, by climate scientists. It also serves as the base building block for <code>ClimateTools</code>, which offers more advanced functionalities.</p><p>The focus of <code>ClimateBase</code> is <strong>not</strong> loading data, nor operating on data <em>on disk</em>. It is designed for in-memory climate data exploration and manipulation. That being said, basic data loading functionality is offered in terms of <code>NCDatasets</code>, see below.</p><h3 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h3><p>This package is registered and you can install it with</p><pre><code class="language-julia">using Pkg; Pkg.add(&quot;ClimateBase&quot;)</code></pre><p>Make sure your installed version coincides with the one in this docs (see bottom left corner of this page).</p><h2 id="ClimArray:-the-core-data-structure"><a class="docs-heading-anchor" href="#ClimArray:-the-core-data-structure"><code>ClimArray</code>: the core data structure</a><a id="ClimArray:-the-core-data-structure-1"></a><a class="docs-heading-anchor-permalink" href="#ClimArray:-the-core-data-structure" title="Permalink"></a></h2><p>This project treats &quot;climate data&quot; as an instance of <a href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimArray</code></a>. At the moment <code>ClimArray</code> is a subtype of <code>DimensionalArray</code> from DimensionalData.jl. A brief introduction to DimensionalData.jl is copied here from its docs, because basic handling of a <code>ClimArray</code> comes from DimensionalData.jl. DimensionalData.jl allows to dimensionally-index data by their values.</p><p>E.g. you can create an array with</p><pre><code class="language-julia">using ClimateBase, Dates
Time = ClimateBase.Ti # `Time` is more intuitive than `Ti`
lats = -90:5:90
lons = 0:10:359
t = Date(2000, 3, 15):Month(1):Date(2020, 3, 15)
# Here we wrap all dimension data into proper dimensions:
dimensions = (Lon(lons), Lat(lats), Time(t))
# where `Lon, Lat, Time` are `Dimension`s exported by ClimateBase
# combining the array data with dimensions makes a `ClimArray`:
data = rand(36, 37, 241) # same size as `dimensions`
A = ClimArray(data, dimensions)</code></pre><pre class="documenter-example-output">ClimArray with dimensions:
 Longitude (type Lon): 0:10:350 (Sampled: Ordered Regular Points)
 Latitude (type Lat): -90:5:90 (Sampled: Ordered Regular Points)
 Time (type Ti): Dates.Date(&quot;2000-03-15&quot;):Dates.Month(1):Dates.Date(&quot;2020-03-15&quot;) (Sampled: Ordered Regular Points)
and data: 36×37×241 Array{Float64, 3}
[:, :, 1]
 0.0594354  0.389453  0.611181  0.296815   …  0.875409   0.835412  0.124078
 0.142844   0.979434  0.95313   0.664377      0.68268    0.730498  0.996821
 0.218345   0.346917  0.337108  0.69327       0.544767   0.861901  0.191773
 0.0279894  0.294972  0.740461  0.192701      0.962871   0.844936  0.497207
 ⋮                                         ⋱             ⋮         
 0.237073   0.752323  0.897195  0.960893      0.984954   0.878342  0.520621
 0.841549   0.114277  0.413736  0.370325      0.0192143  0.954437  0.655913
 0.30103    0.397606  0.773104  0.418003      0.677386   0.667883  0.914721
 0.390222   0.040336  0.444415  0.0245964  …  0.622927   0.581489  0.289075
[and 240 more slices...]</pre><p>You can then select a specific time slice at <code>Date(2011,5,15)</code> and a longitude interval between 0 and 30 degrees like so:</p><pre><code class="language-julia">B = A[Lon(Between(0, 30)), Time(At(Date(2011,5,15)))]</code></pre><pre class="documenter-example-output">ClimArray with dimensions:
 Longitude (type Lon): 0:10:30 (Sampled: Ordered Regular Points)
 Latitude (type Lat): -90:5:90 (Sampled: Ordered Regular Points)
and data: 4×37 Matrix{Float64}
 0.112522  0.349709  0.920815   0.899776  …  0.686969   0.361194  0.431792
 0.720055  0.314922  0.702455   0.897673     0.0749245  0.504951  0.0874879
 0.842258  0.446023  0.0208391  0.887857     0.893362   0.879501  0.188492
 0.46931   0.911947  0.622496   0.76429      0.61018    0.959781  0.400078</pre><p>With <code>ClimArray</code> you can use convenience, physically-inspired functions that do automatic (and correct) weighting. For example the latitudinal mean of <code>B</code> is simply</p><pre><code class="language-julia">C = latmean(B)</code></pre><pre class="documenter-example-output">ClimArray with dimensions:
 Longitude (type Lon): 0:10:30 (Sampled: Ordered Regular Points)
and data: 4-element Vector{Float64}
[0.473173, 0.518584, 0.532628, 0.589493]</pre><p>where in this averaging process each data point is weighted by the cosine of its latitude.</p><h3 id="Making-a-ClimArray"><a class="docs-heading-anchor" href="#Making-a-ClimArray">Making a <code>ClimArray</code></a><a id="Making-a-ClimArray-1"></a><a class="docs-heading-anchor-permalink" href="#Making-a-ClimArray" title="Permalink"></a></h3><p>You can create a <code>ClimArray</code> yourself, or you can load data from an <code>.nc</code> file with CF-conventions, see <a href="#NetCDF-IO">NetCDF IO</a>.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}" href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimateBase.ClimArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ClimArray(A::Array, dims::Tuple; name = &quot;&quot;, attrib = nothing)</code></pre><p><code>ClimArray</code> is a structure that contains numerical array data bundled with dimensional information, a name and an <code>attrib</code> field (typically a dictionary) that holds general attributes. You can think of <code>ClimArray</code> as a in-memory representation of a CFVariable.</p><p>At the moment, a <code>ClimArray</code> is using <code>DimensionalArray</code> from DimensionalData.jl, and all basic handling of <code>ClimArray</code> is offered by <code>DimensionalData</code> (see below).</p><p><code>ClimArray</code> is created by passing in standard array data <code>A</code> and a tuple of dimensions <code>dims</code>. See <a href="#ClimateBase.ncread"><code>ncread</code></a> to automatically create a <code>ClimArray</code> from a .nc file.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ClimateBase, Dates
Time = ClimateBase.Ti # more intuitive name for time dimension
lats = -90:5:90
lons = 0:10:359
t = Date(2000, 3, 15):Month(1):Date(2020, 3, 15)
# dimensional information:
dimensions = (Lon(lons), Lat(lats), Time(t))
data = rand(36, 37, 241) # numeric data
A = ClimArray(data, dimensions)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/core/coredefs.jl#L118-L145">source</a></section></article><p>It is strongly recommended to use the dimensions we export (because we dispatch on them and use their information):</p><pre><code class="language-julia">for D in ClimateBase.STANDARD_DIMS
    println(D, &quot; (full name = $(DimensionalData.name(D)))&quot;)
end</code></pre><pre class="documenter-example-output">Lon (full name = Longitude)
Lat (full name = Latitude)
Ti (full name = Time)
Hei (full name = Height)
Pre (full name = Pressure)
Coord (full name = Spatial Coordinates)</pre><p>We explicitly assume that <code>Lon, Lat</code> are measured in degrees and not radians or meters (extremely important for spatial averaging processes).</p><h2 id="NetCDF-IO"><a class="docs-heading-anchor" href="#NetCDF-IO">NetCDF IO</a><a id="NetCDF-IO-1"></a><a class="docs-heading-anchor-permalink" href="#NetCDF-IO" title="Permalink"></a></h2><p>ClimateBase.jl has support for <code>file.nc ⇆ ClimArray</code>. Usually this is done using NCDatasets.jl, but see below for a function that translates a loaded <code>xarray</code> (from Python) into <code>ClimArray</code>.</p><h3 id="Read"><a class="docs-heading-anchor" href="#Read">Read</a><a id="Read-1"></a><a class="docs-heading-anchor-permalink" href="#Read" title="Permalink"></a></h3><p>To load a <code>ClimArray</code> directly from an <code>.nc</code> file do:</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ncread" href="#ClimateBase.ncread"><code>ClimateBase.ncread</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ncread(file::Union{String,NCDataset}, var::String; name, grid) → A</code></pre><p>Load the variable <code>var</code> from the <code>file</code> and convert it into a <a href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimArray</code></a>. with proper dimension mapping and also containing the variable attributes as a dictionary. Dimension attributes are also given to the dimensions of <code>A</code>, if any exist.</p><p>Notice that <code>file</code> can be an <code>NCDataset</code>, which allows you to lazily combine different <code>.nc</code> data (typically split by time), e.g.</p><pre><code class="language-julia">alldata = [&quot;toa_fluxes_2020_$(i).nc&quot; for i in 1:12]
file = NCDataset(alldata; aggdim = &quot;time&quot;)
A = ClimArray(file, &quot;tow_sw_all&quot;)</code></pre><p>(but you can also directly give the string to a single file <code>&quot;file.nc&quot;</code> if data are contained in a single file).</p><p>We do two performance improvements while loading the data:</p><ol><li>If there are no missing values in the data (according to CF standards), the returned array is automatically converted to a concrete type (i.e. <code>Union{Float32, Missing}</code> becomes <code>Float32</code>).</li><li>Dimensions that are ranges (i.e. sampled with constant step size) are automatically transformed to a standard Julia <code>Range</code> type (which makes sub-selecting faster).</li></ol><p><strong>Keywords</strong></p><ul><li><code>name = var</code> optionally rename loaded array.</li><li><code>grid = nothing</code> optionally specify whether the underlying grid is <code>grid = LonLatGrid()</code> or <code>grid = UnstructuredGrid()</code>, see <a href="#Types-of-spatial-coordinates">Types of spatial coordinates</a>. If <code>nothing</code>, we try to deduce automatically based on the names of dimensions and other keys of the <code>NCDataset</code>.</li></ul><p>See also <a href="#ClimateBase.ncwrite"><code>ncwrite</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/core/nc_io.jl#L55-L86">source</a></section></article><p>Notice that (at the moment) we use a pre-defined mapping of common names to proper dimensions - please feel free to extend the following via a Pull Request:</p><pre><code class="language-julia">ClimateBase.COMMONNAMES</code></pre><pre class="documenter-example-output">Dict{String, UnionAll} with 15 entries:
  &quot;lat&quot;       =&gt; Lat
  &quot;altitude&quot;  =&gt; Hei
  &quot;time&quot;      =&gt; Ti
  &quot;pressure&quot;  =&gt; Pre
  &quot;xc&quot;        =&gt; Lon
  &quot;x&quot;         =&gt; Lon
  &quot;lon&quot;       =&gt; Lon
  &quot;level&quot;     =&gt; Pre
  &quot;latitude&quot;  =&gt; Lat
  &quot;height&quot;    =&gt; Hei
  &quot;long&quot;      =&gt; Lon
  &quot;longitude&quot; =&gt; Lon
  &quot;t&quot;         =&gt; Ti
  &quot;yc&quot;        =&gt; Lat
  &quot;y&quot;         =&gt; Lat</pre><p>Also, the following convenience functions are provided for examining the content of on-disk <code>.nc</code> files without loading all data on memory.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.nckeys" href="#ClimateBase.nckeys"><code>ClimateBase.nckeys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nckeys(file::String)</code></pre><p>Return all keys of the <code>.nc</code> file in <code>file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/core/nc_io.jl#L20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ncdetails" href="#ClimateBase.ncdetails"><code>ClimateBase.ncdetails</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ncdetails(file::String, io = stdout)</code></pre><p>Print details about the <code>.nc</code> file in <code>file</code> on <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/core/nc_io.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.globalattr" href="#ClimateBase.globalattr"><code>ClimateBase.globalattr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">globalattr(file::String) → Dict</code></pre><p>Return the global attributes of the .nc file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/core/nc_io.jl#L42-L45">source</a></section></article><h3 id="Write"><a class="docs-heading-anchor" href="#Write">Write</a><a id="Write-1"></a><a class="docs-heading-anchor-permalink" href="#Write" title="Permalink"></a></h3><p>You can also write a bunch of <code>ClimArray</code>s directly into an <code>.nc</code> file with</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ncwrite" href="#ClimateBase.ncwrite"><code>ClimateBase.ncwrite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ncwrite(file::String, Xs; globalattr = Dict())</code></pre><p>Write the given <code>ClimArray</code> instances (any iterable of <code>ClimArray</code>s or a single <code>ClimArray</code>) to a <code>.nc</code> file following CF standard conventions using NCDatasets.jl. Optionally specify global attributes for the <code>.nc</code> file.</p><p>The metadata of the arrays in <code>Xs</code>, as well as their dimensions, are properly written in the <code>.nc</code> file and any necessary type convertions happen automatically.</p><p><strong>WARNING</strong>: We assume that any dimensions shared between the <code>Xs</code> are identical.</p><p>See also <a href="#ClimateBase.ncread"><code>ncread</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/core/nc_io.jl#L305-L317">source</a></section></article><h3 id="xarray"><a class="docs-heading-anchor" href="#xarray">xarray</a><a id="xarray-1"></a><a class="docs-heading-anchor-permalink" href="#xarray" title="Permalink"></a></h3><p>You can use the following functions (which are not defined and exported in <code>ClimateBase</code> to avoid dependency on PyCall.jl) to load data using Python&#39;s <code>xarray</code>.</p><pre><code class="language-julia">using ClimateBase, Dates
# This needs to numpy, xarray and dask installed from Conda
using PyCall
xr = pyimport(&quot;xarray&quot;)
np = pyimport(&quot;numpy&quot;)

function climarray_from_xarray(xa, fieldname, name = fieldname)
    w = getproperty(xa, Symbol(fieldname))
    raw_data = Array(w.values)
    dnames = collect(w.dims) # dimensions in string name
    dim_values, dim_attrs = extract_dimension_values_xarray(xa, dnames)
    @assert collect(size(raw_data)) == length.(dim_values)
    actual_dims = create_dims_xarray(dnames, dim_values, dim_attrs)
    ca = ClimArray(raw_data, actual_dims, name; attrib = w.attrs)
end

function extract_dimension_values_xarray(xa, dnames = collect(xa.dims))
    dim_values = []
    dim_attrs = Vector{Any}(fill(nothing, length(dnames)))
    for (i, d) in enumerate(dnames)
        dim_attrs[i] = getproperty(xa, d).attrs
        x = getproperty(xa, d).values
        if d ≠ &quot;time&quot;
            push!(dim_values, x)
        else
            dates = [np.datetime_as_string(y)[1:19] for y in x]
            dates = DateTime.(dates)
            push!(dim_values, dates)
        end
    end
    return dim_values, dim_attrs
end

function create_dims_xarray(dnames, dim_values, dim_attrs)
    true_dims = ClimateBase.to_proper_dimensions(dnames)
    optimal_values = ClimateBase.vector2range.(dim_values)
    out = []
    for i in 1:length(true_dims)
        push!(out, true_dims[i](optimal_values[i]; metadata = dim_attrs[i]))
    end
    return (out...,)
end

# Load some data
xa = xr.open_mfdataset(ERA5_files_path)
X = climarray_from_xarray(xa, &quot;w&quot;, &quot;optional name&quot;)</code></pre><h2 id="Temporal"><a class="docs-heading-anchor" href="#Temporal">Temporal</a><a id="Temporal-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal" title="Permalink"></a></h2><p>Functions related with the <code>Time</code> dimension.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.timemean" href="#ClimateBase.timemean"><code>ClimateBase.timemean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timemean(A::ClimArray [, w]) = timeagg(mean, A, w)</code></pre><p>Temporal average of <code>A</code>, see <a href="#ClimateBase.timeagg"><code>timeagg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/temporal.jl#L182-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.timeagg" href="#ClimateBase.timeagg"><code>ClimateBase.timeagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timeagg(f, A::ClimArray, W = nothing)</code></pre><p>Perform a proper temporal aggregation of the function <code>f</code> (e.g. <code>mean, std</code>) on <code>A</code> where:</p><ul><li>Only full year spans of <code>A</code> are included, see <a href="#ClimateBase.maxyearspan"><code>maxyearspan</code></a> (because most processes are affected by yearly cycle, and averaging over an uneven number of cycles typically results in artifacts)</li><li>Each month in <code>A</code> is weighted with its length in days (for monthly sampled data)</li></ul><p>If you don&#39;t want these features, just do <a href="#ClimateBase.dropagg"><code>dropagg</code></a><code>(f, A, Time, W)</code>. This is also done in the case where the time sampling is unknown.</p><p><code>W</code> are possible statistical weights that are used in conjuction to the temporal weighting, to weight each time point differently. If they are not a vector (a weight for each time point), then they have to be a dimensional array of same dimensional layout as <code>A</code> (a weight for each data point).</p><p>See also <a href="#ClimateBase.monthlyagg"><code>monthlyagg</code></a>, <a href="#ClimateBase.yearlyagg"><code>yearlyagg</code></a>, <a href="#ClimateBase.seasonalyagg"><code>seasonalyagg</code></a>.</p><pre><code class="language-none">timeagg(f, t::Vector, x::Vector, w = nothing)</code></pre><p>Same as above, but for arbitrary vector <code>x</code> accompanied by time vector <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/temporal.jl#L189-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.monthlyagg" href="#ClimateBase.monthlyagg"><code>ClimateBase.monthlyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">monthlyagg(A::ClimArray, f = mean; mday = 15) -&gt; B</code></pre><p>Create a new array where the temporal information has been aggregated into months using the function <code>f</code>. The dates of the new array always have day number of <code>mday</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/temporal.jl#L303-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.yearlyagg" href="#ClimateBase.yearlyagg"><code>ClimateBase.yearlyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yearlyagg(A::ClimArray, f = mean) -&gt; B</code></pre><p>Create a new array where the temporal information has been aggregated into years using the function <code>f</code>. By convention, the dates of the new array always have month and day number of <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/temporal.jl#L318-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.seasonalyagg" href="#ClimateBase.seasonalyagg"><code>ClimateBase.seasonalyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seasonalyagg(A::ClimArray, f = mean) -&gt; B</code></pre><p>Create a new array where the temporal information has been aggregated into seasons using the function <code>f</code>. By convention, seasons are represented as Dates spaced 3-months apart, where only the months December, March, June and September are used to specify the date, with day 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/temporal.jl#L370-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.temporalrange" href="#ClimateBase.temporalrange"><code>ClimateBase.temporalrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">temporalrange(A::ClimArray, f = Dates.month) → r
temporalrange(t::AbstractVector{&lt;:TimeType}}, f = Dates.month) → r</code></pre><p>Return a vector of ranges so that each range of indices are values of <code>t</code> that belong in either the same month, year, day, or season, depending on <code>f</code>. <code>f</code> can take the values: <code>Dates.year, Dates.month, Dates.day</code> or <code>season</code> (all are functions).</p><p>Used in e.g. <a href="#ClimateBase.monthlyagg"><code>monthlyagg</code></a>, <a href="#ClimateBase.yearlyagg"><code>yearlyagg</code></a> or <a href="#ClimateBase.seasonalyagg"><code>seasonalyagg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/temporal.jl#L343-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.maxyearspan" href="#ClimateBase.maxyearspan"><code>ClimateBase.maxyearspan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maxyearspan(A::ClimArray) = maxyearspan(dims(A, Time))
maxyearspan(t::Vector{&lt;:DateTime}) → i</code></pre><p>Find the maximum index <code>i</code> of <code>t</code> so that <code>t[1:i]</code> covers exact(*) multiples of years.</p><p>(*) For monthly spaced data <code>i</code> is a multiple of <code>12</code> while for daily data we find the largest possible multiple of <code>DAYS_IN_ORBIT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/temporal.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.temporal_sampling" href="#ClimateBase.temporal_sampling"><code>ClimateBase.temporal_sampling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">temporal_sampling(x) → symbol</code></pre><p>Return the temporal sampling type of <code>x</code>, which is either an array of <code>Date</code>s or a dimensional array (with <code>Time</code> dimension).</p><p>Possible return values are:</p><ul><li><code>:hourly</code>, where the temporal difference between entries is exactly 1 hour.</li><li><code>:daily</code>, where the temporal difference between dates is exactly 1 day.</li><li><code>:monthly</code>, where all dates have the same day, but different month.</li><li><code>:yearly</code>, where all dates have the same month+day, but different year.</li><li><code>:other</code>, which means that <code>x</code> doesn&#39;t fall to any of the above categories.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/temporal.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.time_in_days" href="#ClimateBase.time_in_days"><code>ClimateBase.time_in_days</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_in_days(t::AbstractArray{&lt;:TimeType}, T = Float32)</code></pre><p>Convert a given date time array into measurement units of days: a real-valued array which counts time in days, always increasing (cumulative).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/temporal.jl#L159-L163">source</a></section></article><h2 id="Spatial"><a class="docs-heading-anchor" href="#Spatial">Spatial</a><a id="Spatial-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial" title="Permalink"></a></h2><h3 id="Spatial-aggregation"><a class="docs-heading-anchor" href="#Spatial-aggregation">Spatial aggregation</a><a id="Spatial-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-aggregation" title="Permalink"></a></h3><p>All functions in this section work for both types of space, see <a href="#Types-of-spatial-coordinates">Types of spatial coordinates</a>.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.zonalmean" href="#ClimateBase.zonalmean"><code>ClimateBase.zonalmean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">zonalmean(A::ClimArray)</code></pre><p>Return the zonal mean of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/spatial.jl#L74-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.latmean" href="#ClimateBase.latmean"><code>ClimateBase.latmean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">latmean(A::ClimArray)</code></pre><p>Return the latitude-mean <code>A</code> (mean across dimension <code>Lat</code>). This function properly weights by the cosine of the latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/spatial.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spacemean" href="#ClimateBase.spacemean"><code>ClimateBase.spacemean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spacemean(A::ClimArray [, W]) = spaceagg(mean, A, W)</code></pre><p>Average given <code>A</code> over its spatial coordinates. Optionally provide statistical weights in <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/spatial.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spaceagg" href="#ClimateBase.spaceagg"><code>ClimateBase.spaceagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spaceagg(f, A::ClimArray, W = nothing)</code></pre><p>Aggregate <code>A</code> using function <code>f</code> (e.g. <code>mean, std</code>) over all available space (i.e. longitude and latitude) of <code>A</code>, weighting every part of <code>A</code> by its spatial area.</p><p><code>W</code> can be extra weights, to weight each spatial point with. <code>W</code> can either be just a <code>ClimArray</code> with same space as <code>A</code>, or of exactly same shape as <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/spatial.jl#L113-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.hemispheric_means" href="#ClimateBase.hemispheric_means"><code>ClimateBase.hemispheric_means</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hemispheric_means(A) → nh, sh</code></pre><p>Return the (proper) averages of <code>A</code> over the northern and southern hemispheres. Notice that this function explicitly does both zonal as well as meridional averaging. Use <a href="#ClimateBase.hemispheric_functions"><code>hemispheric_functions</code></a> to just split <code>A</code> into two hemispheres.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/spatial.jl#L195-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.hemispheric_functions" href="#ClimateBase.hemispheric_functions"><code>ClimateBase.hemispheric_functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hemispheric_functions(A::ClimArray) → north, south</code></pre><p>Return two arrays <code>north, south</code>, by splitting <code>A</code> to its northern and southern hemispheres, appropriately translating the latitudes of <code>south</code> so that both arrays have the same latitudinal dimension (and thus can be compared and do opperations between them).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/spatial.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.lonlatfirst" href="#ClimateBase.lonlatfirst"><code>ClimateBase.lonlatfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lonlatfirst(A::ClimArray, args...) → B</code></pre><p>Permute the dimensions of <code>A</code> to make a new array <code>B</code> that has first dimension longitude, second dimension latitude, with the remaining dimensions of <code>A</code> following (useful for most plotting functions). Optional extra dimensions can be given as <code>args...</code>, specifying a specific order for the remaining dimensions.</p><p>Example:</p><pre><code class="language-julia">B = lonlatfirst(A)
C = lonlatfirst(A, Time)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/spatial.jl#L30-L42">source</a></section></article><h3 id="Types-of-spatial-coordinates"><a class="docs-heading-anchor" href="#Types-of-spatial-coordinates">Types of spatial coordinates</a><a id="Types-of-spatial-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-spatial-coordinates" title="Permalink"></a></h3><p>At the moment the following type of spatial coordinates are supported:</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.LonLatGrid" href="#ClimateBase.LonLatGrid"><code>ClimateBase.LonLatGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Space coordinates are represented by two orthogonal dimensions <code>Lon, Lat</code>, one being longitude and the other being latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/core/coredefs.jl#L64-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.UnstructuredGrid" href="#ClimateBase.UnstructuredGrid"><code>ClimateBase.UnstructuredGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Space coordinates are represented by a single dimension <code>Coord</code>, elements are coordinate locations, i.e. 2-element <code>SVector(longitude, latitude)</code>. Each coordinate represents an equal area polygon corresponding to the point in space. The actual limits of each polygon are not included in the dimension for performance reasons.</p><p>To use functions such as <a href="#ClimateBase.zonalmean"><code>zonalmean</code></a> or <a href="#ClimateBase.hemispheric_means"><code>hemispheric_means</code></a> with this grid, you must first sort the <code>ClimArray</code> so that the latitudes of its coordinates are sorted in ascending order. I.e.</p><pre><code class="language-julia">A # some `ClimArray` with unstructured grid type.
coords = dims(A, Coord).val
si = sortperm(coords, by = reverse)
A = A[Coord(si)]</code></pre><p><strong>This is done automatically by <a href="#ClimateBase.ncread"><code>ncread</code></a>.</strong></p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p><code>UnstructuredGrid</code> functionality is currently in an <strong>experimental phase</strong>!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/core/coredefs.jl#L70-L89">source</a></section></article><p>Notice that non-equal area unstructured grids are not supported yet.</p><p>ClimateBase.jl works with either type of spatial coordinate system. Therefore, physically inspired averaging functions, like <a href="#ClimateBase.spacemean"><code>spacemean</code></a> or <a href="#ClimateBase.zonalmean"><code>zonalmean</code></a>, work for both types of spatial coordinates. In addition, the function <code>spatialidxs</code> returns an iterator over the spatial coordinates of the data, and works for both types (grid or equal-area):</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spatialidxs" href="#ClimateBase.spatialidxs"><code>ClimateBase.spatialidxs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spatialidxs(A::ClimArray) → idxs</code></pre><p>Return an iterable that can be used to access all spatial points of <code>A</code> with the syntax</p><pre><code class="language-julia">idxs = spatialidxs(A)
for i in idxs
    slice_at_give_space_point = A[i...]
end</code></pre><p>Works for all types of space (<code>...</code> is necessary because <code>i</code> is a <code>Tuple</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/physical_dimensions/spatial.jl#L12-L22">source</a></section></article><p><a href="#ClimateBase.ncread"><code>ncread</code></a> tries to automatically deduce the correct space type and create the appropriate dimension.</p><h2 id="General-aggregation"><a class="docs-heading-anchor" href="#General-aggregation">General aggregation</a><a id="General-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#General-aggregation" title="Permalink"></a></h2><p>The physical averages of the previous section are done by taking advantage of a general aggregation syntax, which works with any aggregating function like <code>mean, sum, std</code>, etc.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.dropagg" href="#ClimateBase.dropagg"><code>ClimateBase.dropagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropagg(f, A, dims)</code></pre><p>Apply statistics/aggregating function <code>f</code> (e.g. <code>sum</code> or <code>mean</code>) on array <code>A</code> across dimension(s) <code>dims</code> and drop the corresponding dimension(s) from the result (Julia inherently keeps singleton dimensions).</p><p>If <code>A</code> is one dimensional, <code>dropagg</code> will return the single number of applying <code>f(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/core/aggregation.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.collapse" href="#ClimateBase.collapse"><code>ClimateBase.collapse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collapse(f, A, dim)</code></pre><p>Reduce <code>A</code> towards dimension <code>dim</code> using the collapsing function <code>f</code> (e.g. <code>mean</code>). This means that <code>f</code> is applied across all other dimensions of <code>A</code>, each of which are subsequently dropped, leaving only the collapsed result of <code>A</code> vs. the remaining dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/core/aggregation.jl#L43-L48">source</a></section></article><h2 id="Timeseries-Analysis"><a class="docs-heading-anchor" href="#Timeseries-Analysis">Timeseries Analysis</a><a id="Timeseries-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Timeseries-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.sinusoidal_continuation" href="#ClimateBase.sinusoidal_continuation"><code>ClimateBase.sinusoidal_continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sinusoidal_continuation(T::ClimArray, fs = [1, 2]; Tmin = -Inf, Tmax = Inf)</code></pre><p>Fill-in the missing values of spatiotemporal field <code>T</code>, by fitting sinusoidals to the non-missing values, and then using the fitted sinusoidals for the missing values.</p><p>Frequencies are given per year (frequency 2 means 1/2 of a year).</p><p><code>Tmin, Tmax</code> limits are used to clamp the result into this range (no clamping in the default case).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/tsa/continuation.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.seasonal_decomposition" href="#ClimateBase.seasonal_decomposition"><code>ClimateBase.seasonal_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seasonal_decomposition(A::ClimArray, fs = [1, 2]) → seasonal, residual</code></pre><p>Decompose <code>A</code> into a seasonal and residual components, where the seasonal contains the periodic parts of <code>A</code>, with frequencies given in <code>fs</code>, and residual contains what&#39;s left.</p><p><code>fs</code> is measured in 1/year. This function works even for non-equispaced time axis (e.g. monthly averages) and uses LPVSpectral.jl and SignalDecomposition.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/tsa/decomposition.jl#L5-L12">source</a></section></article><h2 id="Climate-quantities"><a class="docs-heading-anchor" href="#Climate-quantities">Climate quantities</a><a id="Climate-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Climate-quantities" title="Permalink"></a></h2><p>Functions that calculate climate-related quantities.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.insolation" href="#ClimateBase.insolation"><code>ClimateBase.insolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insolation(t, ϕ; kwargs...)</code></pre><p>Calculate daily averaged insolation in W/m² at given time and latitude <code>t, φ</code>. <code>φ</code> is given in <strong>degrees</strong>, and <code>t</code> in <strong>days</strong> (real number or date).</p><p>Keywords:</p><pre><code class="language-none">Ya = DAYS_IN_ORBIT # = 365.26 # days
t_VE = 76.0 # days of vernal equinox
S_0 = 1362.0 # W/m^2
γ=23.44
ϖ=282.95
e=0.017 # eccentricity</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/climate/solar.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.surface_atmosphere_contributions" href="#ClimateBase.surface_atmosphere_contributions"><code>ClimateBase.surface_atmosphere_contributions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">surface_atmosphere_contributions(I, F_toa_⬆, F_s_⬆, F_s_⬇) → α_ATM, α_SFC</code></pre><p>Calculate the atmospheric and surface <strong>contributions</strong> of the planetary albedo, so that the TOA albedo is <code>α = α_ATM + α_SFC</code>, using the simple 1-layer radiative transfer model by Donohoe &amp; Battisti (2011) or G. Stephens (2015). Stephens&#39; formulas are incorrect and I have corrected them!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/climate/albedo.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.total_toa_albedo" href="#ClimateBase.total_toa_albedo"><code>ClimateBase.total_toa_albedo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">total_toa_albedo(a, s, t) = a + s*t^2/(1-a*s)</code></pre><p>Combine given atmosphere albedo <code>a</code>, surface albedo <code>s</code> and atmosphere transmittance <code>t</code> into a total top-of-the-atmosphere albedo <code>α</code> according to the model of Donohoe &amp; Battisti (2011).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/8155d09ef5a43d372532bd503e23aef680aff131/src/climate/albedo.jl#L30-L34">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>Currently ClimateBase.jl does not have integrated plotting support. In the near future it will have this based on the upcoming GeoMakie.jl.</p><p>For now, you can use PyCall.jl, matplotlib, and the Python library cartopy. In the file <a href="https://github.com/JuliaClimate/ClimateBase.jl/tree/master/plotting/python.jl"><code>ClimateBase/plotting/python.jl</code></a> we provide two functions that plot maps of <code>ClimArray</code> in arbitrary projections: <code>earthsurface</code> for <code>LonLatGrid</code> and <code>earthscatter</code> for <code>UnstructuredGrid</code>. You can incorporate these in your source code as a temporary solution.</p><h2 id="Ensemble-types"><a class="docs-heading-anchor" href="#Ensemble-types">Ensemble types</a><a id="Ensemble-types-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-types" title="Permalink"></a></h2><p>A dedicated type representing ensembles has no reason to exist in ClimateBase.jl. As the package takes advantage of standard Julia datastructures and syntax, those can be used to represent &quot;ensembles&quot;. For example to do an &quot;ensemble global mean&quot; you can just do:</p><pre><code class="language-julia">E = [ClimArray(&quot;ensemble_$i.nc&quot;, &quot;x&quot;) for i in 1:10]
global_mean = mean(spacemean(X) for X in E)</code></pre><p>where you see that the &quot;ensemble&quot; was represented just as a <code>Vector{ClimArray}</code>.</p><h2 id="Crash-course-to-DimensionalData.jl"><a class="docs-heading-anchor" href="#Crash-course-to-DimensionalData.jl">Crash-course to DimensionalData.jl</a><a id="Crash-course-to-DimensionalData.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Crash-course-to-DimensionalData.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData" href="#DimensionalData"><code>DimensionalData</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>DimensionalData</strong></p><p><a href="https://rafaqz.github.io/DimensionalData.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://rafaqz.github.io/DimensionalData.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <img src="https://github.com/rafaqz/DimensionalData.jl/workflows/CI/badge.svg" alt="CI"/> <a href="https://codecov.io/gh/rafaqz/DimensionalData.jl"><img src="https://codecov.io/gh/rafaqz/DimensionalData.jl/branch/master/graph/badge.svg" alt="Codecov"/></a> <a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://img.shields.io/badge/Aqua.jl-%F0%9F%8C%A2-aqua.svg" alt="Aqua.jl Quality Assurance"/></a></p><p>DimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions. It&#39;s a pluggable, generalised version of <a href="https://github.com/JuliaArrays/AxisArrays.jl">AxisArrays.jl</a> with a cleaner syntax, and additional functionality found in NamedDims.jl. It has similar goals to pythons <a href="http://xarray.pydata.org/en/stable/">xarray</a>, and is primarily written for use with spatial data in <a href="https://github.com/rafaqz/GeoData.jl">GeoData.jl</a>.</p><p><strong>Dimensions</strong></p><p>Dimensions are just wrapper types. They store the dimension index and define details about the grid and other metadata, and are also used to index into the array, wrapping a value or a <code>Selector</code>. <code>X</code>, <code>Y</code>, <code>Z</code> and <code>Ti</code> are the exported defaults.</p><p>A generalised <code>Dim</code> type is available to use arbitrary symbols to name dimensions. Custom dimensions can be defined using the <code>@dim</code> macro.</p><p>We can use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:</p><pre><code class="language-julia">julia&gt; using DimensionalData

julia&gt; A = DimArray(rand(40, 50), (X, Y));

julia&gt; A[Y(1), X(1:10)]
DimArray with dimensions:
 X: 1:10 (NoIndex)
and referenced dimensions:
 Y: 1 (NoIndex)
and data: 10-element Array{Float64,1}
[0.515774, 0.575247, 0.429075, 0.234041, 0.4484, 0.302562, 0.911098, 0.541537, 0.267234, 0.370663]</code></pre><p>And this has no runtime cost:</p><pre><code class="language-julia">julia&gt; A = DimArray(rand(40, 50), (X, Y));

julia&gt; @btime $A[X(1), Y(2)]
  2.092 ns (0 allocations: 0 bytes)
0.27317596504655417

julia&gt; @btime parent($A)[1, 2]
  2.092 ns (0 allocations: 0 bytes)
0.27317596504655417</code></pre><p>Dims can be used for indexing and views without knowing dimension order:</p><pre><code class="language-julia">julia&gt; A[X(10)]
DimArray with dimensions:
 Y (type Y): Base.OneTo(50) (NoIndex)
and referenced dimensions:
 X (type X): 10 (NoIndex)
and data: 50-element Array{Float64,1}
[0.0850249, 0.313408, 0.0762157, 0.549103, 0.297763, 0.309075, 0.854535, 0.659537, 0.392969, 0.89998  …  0.63791, 0.875881, 0.437688, 0.925918, 0.291636, 0.358024, 0.692283, 0.606932, 0.629122, 0.284592]

julia&gt; view(A, Y(30:40), X(1:5))
DimArray with dimensions:
 X (type X): 1:5 (NoIndex)
 Y (type Y): 30:40 (NoIndex)
and data: 5×11 view(::Array{Float64,2}, 1:5, 30:40) with eltype Float64
 0.508793   0.721117  0.558849  …  0.505518   0.532322
 0.869126   0.754219  0.328315     0.0148934  0.778308
 0.0596468  0.458492  0.250458     0.980508   0.524938
 0.446838   0.659638  0.632399     0.33478    0.549402
 0.292962   0.995038  0.26026      0.526124   0.589176</code></pre><p>And for indicating dimensions to reduce or permute in julia <code>Base</code> and <code>Statistics</code> functions that have dims arguments:</p><pre><code class="language-julia">julia&gt; using Statistics

julia&gt; A = DimArray(rand(3, 4, 5), (X, Y, Ti));

julia&gt; mean(A, dims=Ti)
DimArray with dimensions:
 X (type X): Base.OneTo(3) (NoIndex)
 Y (type Y): Base.OneTo(4) (NoIndex)
 Time (type Ti): 1 (NoIndex)
and data: 3×4×1 Array{Float64,3}
[:, :, 1]
 0.495295  0.650432  0.787521  0.502066
 0.576573  0.568132  0.770812  0.504983
 0.39432   0.5919    0.498638  0.337065
[and 0 more slices...]

julia&gt; permutedims(A, [Ti, Y, X])
DimArray with dimensions:
 Time (type Ti): Base.OneTo(5) (NoIndex)
 Y (type Y): Base.OneTo(4) (NoIndex)
 X (type X): Base.OneTo(3) (NoIndex)
and data: 5×4×3 Array{Float64,3}
[:, :, 1]
 0.401374  0.469474  0.999326  0.265688
 0.439387  0.57274   0.493883  0.88678
 0.425845  0.617372  0.998552  0.650999
 0.852777  0.954702  0.928367  0.0045136
 0.357095  0.637873  0.517476  0.702351
[and 2 more slices...]</code></pre><p>You can also use symbols to create <code>Dim{X}</code> dimensions:</p><pre><code class="language-julia">julia&gt; A = DimArray(rand(10, 20, 30), (:a, :b, :c));

julia&gt; A[a=2:5, c=9]

DimArray with dimensions:
 Dim{:a}: 2:5 (NoIndex)
 Dim{:b}: Base.OneTo(20) (NoIndex)
and referenced dimensions:
 Dim{:c}: 9 (NoIndex)
and data: 4×20 Array{Float64,2}
 0.868237   0.528297   0.32389   …  0.89322   0.6776    0.604891
 0.635544   0.0526766  0.965727     0.50829   0.661853  0.410173
 0.732377   0.990363   0.728461     0.610426  0.283663  0.00224321
 0.0849853  0.554705   0.594263     0.217618  0.198165  0.661853</code></pre><p><strong>Selectors</strong></p><p>Selectors find indices in the dimension based on values <code>At</code>, <code>Near</code>, or <code>Between</code> the index value(s). They can be used in <code>getindex</code>, <code>setindex!</code> and <code>view</code> to select indices matching the passed in value(s)</p><ul><li><code>At(x)</code>: get indices exactly matching the passed in value(s)</li><li><code>Near(x)</code>: get the closest indices to the passed in value(s)</li><li><code>Where(f::Function)</code>: filter the array axis by a function of dimension index values.</li><li><code>Between(a, b)</code>: get all indices between two values (inclusive)</li><li><code>Contains(x)</code>: get indices where the value x falls in the interval. Only used for <code>Sampled</code> <code>Intervals</code>, for <code>Points</code> us <code>At</code>.</li></ul><p>We can use selectors with dim wrappers:</p><pre><code class="language-julia">using Dates, DimensionalData
timespan = DateTime(2001,1):Month(1):DateTime(2001,12)
A = DimArray(rand(12,10), (Ti(timespan), X(10:10:100)))

julia&gt; A[X(Near(35)), Ti(At(DateTime(2001,5)))]
0.658404535807791

julia&gt; A[Near(DateTime(2001, 5, 4)), Between(20, 50)]
DimArray with dimensions:
 X: 20:10:50
and referenced dimensions:
 Time (type Ti): 2001-05-01T00:00:00
and data: 4-element Array{Float64,1}
[0.456175, 0.737336, 0.658405, 0.520152]</code></pre><p>Without dim wrappers selectors must be in the right order:</p><pre><code class="language-julia">using Unitful

julia&gt; A = DimArray(rand(10, 20), (X((1:10:100)u&quot;m&quot;), Ti((1:5:100)u&quot;s&quot;)))

julia&gt; A[Between(10.5u&quot;m&quot;, 50.5u&quot;m&quot;), Near(23u&quot;s&quot;)]
DimArray with dimensions:
 X: (11:10:41) m (Sampled: Ordered Regular Points)
and referenced dimensions:
 Time (type Ti): 21 s (Sampled: Ordered Regular Points)
and data: 4-element Array{Float64,1}
[0.819172, 0.418113, 0.461722, 0.379877]</code></pre><p>For values other than <code>Int</code>/<code>AbstractArray</code>/<code>Colon</code> (which are set aside for regular indexing) the <code>At</code> selector is assumed, and can be dropped completely:</p><pre><code class="language-julia">julia&gt; A = DimArray(rand(3, 3), (X(Val((:a, :b, :c))), Y([25.6, 25.7, 25.8])));

julia&gt; A[:b, 25.8]
0.61839141062599</code></pre><p><strong>Compile-time selectors</strong></p><p>Using all <code>Val</code> indexes (only recommended for small arrays) you can index with named dimensions <code>At</code> arbitrary values with no runtime cost:</p><pre><code class="language-julia">julia&gt; A = DimArray(rand(3, 3), (cat=Val((:a, :b, :c)),
                                 val=Val((5.0, 6.0, 7.0))));

julia&gt; @btime $A[:a, 7.0]
  2.094 ns (0 allocations: 0 bytes)
0.25620608873275397

julia&gt; @btime $A[cat=:a, val=7.0]
  2.091 ns (0 allocations: 0 bytes)
0.25620608873275397</code></pre><p><strong>Methods where dims can be used containing indices or Selectors</strong></p><p><code>getindex</code>, <code>setindex!</code> <code>view</code></p><p><strong>Methods where dims can be used</strong></p><ul><li><code>size</code>, <code>axes</code>, <code>firstindex</code>, <code>lastindex</code></li><li><code>cat</code></li><li><code>reverse</code></li><li><code>dropdims</code></li><li><code>reduce</code>, <code>mapreduce</code></li><li><code>sum</code>, <code>prod</code>, <code>maximum</code>, <code>minimum</code>,</li><li><code>mean</code>, <code>median</code>, <code>extrema</code>, <code>std</code>, <code>var</code>, <code>cor</code>, <code>cov</code></li><li><code>permutedims</code>, <code>adjoint</code>, <code>transpose</code>, <code>Transpose</code></li><li><code>mapslices</code>, <code>eachslice</code></li><li><code>fill</code></li></ul><p><strong>Warnings</strong></p><p>Indexing with unordered or reverse order arrays has undefined behaviour. It will trash the dimension index, break <code>searchsorted</code> and nothing will make sense any more. So do it at you own risk. However, indexing with sorted vectors of Int can be useful. So it&#39;s allowed. But it will still do strange things to your interval sizes if the dimension span is <code>Irregular</code>.</p><p><strong>Alternate Packages</strong></p><p>There are a lot of similar Julia packages in this space. AxisArrays.jl, NamedDims.jl, NamedArrays.jl are registered alternative that each cover some of the functionality provided by DimensionalData.jl. DimensionalData.jl should be able to replicate most of their syntax and functionality.</p><p><a href="https://github.com/mcabbott/AxisKeys.jl">AxisKeys.jl</a> and <a href="https://github.com/Tokazama/AbstractIndices.jl">AbstractIndices.jl</a> are some other interesting developments. For more detail on why there are so many similar options and where things are headed, read this <a href="https://github.com/JuliaCollections/AxisArraysFuture/issues/1">thread</a>.</p></div></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 18 April 2021 12:36">Sunday 18 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
