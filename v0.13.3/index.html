<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · ClimateBase</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Quicksand|Montserrat|Source+Code+Pro|Lora&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ClimateBase</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#ClimArray:-the-core-data-structure"><span><code>ClimArray</code>: the core data structure</span></a></li><li><a class="tocitem" href="#NetCDF-IO"><span>NetCDF IO</span></a></li><li><a class="tocitem" href="#Temporal"><span>Temporal</span></a></li><li><a class="tocitem" href="#Spatial"><span>Spatial</span></a></li><li><a class="tocitem" href="#General-aggregation"><span>General aggregation</span></a></li><li><a class="tocitem" href="#Missing-data"><span>Missing data</span></a></li><li><a class="tocitem" href="#Timeseries-Analysis"><span>Timeseries Analysis</span></a></li><li><a class="tocitem" href="#Climate-quantities"><span>Climate quantities</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Ensemble-types"><span>Ensemble types</span></a></li><li><a class="tocitem" href="#Crash-course-to-DimensionalData.jl"><span>Crash-course to DimensionalData.jl</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p><code>ClimateBase</code> is a Julia package offering basic functionality for analyzing data that are typically in the form used by climate sciences. These data are dimensional &amp; spatiotemporal but the corresponding dimensions all need special handling. For example the most common dimensions are longitude, latitude and time.</p><ul><li>longitude is by definition a periodic dimension</li><li>latitude is a linear dimension. However because the coordinate system most often used in climate sciences is a grid of longitude × latitude (in equal degrees) the area element of space depends on latitude and this needs to be taken into account.</li><li>time is a linear dimension <em>in principle</em>, but its values are <code>&lt;: AbstractDateTime</code> instead of <code>&lt;: Real</code>. The human calendar (where these values come from) is periodic but each period may not correspond to the same physical time, and this also needs to be taken into account.</li></ul><p><code>ClimateBase</code> is structured to deal with these intricacies, and in addition offer several functionalities commonly used, and sought after, by climate scientists. It also serves as the base building block for <code>ClimateTools</code>, which offers more advanced functionalities.</p><p>At the moment the focus of <code>ClimateBase</code> is <strong>not</strong> on operating on data <em>on disk</em>. It is designed for in-memory climate data exploration and manipulation.</p><h3 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h3><p>This package is registered and you can install it with</p><pre><code class="language-julia">using Pkg; Pkg.add(&quot;ClimateBase&quot;)</code></pre><p>Make sure your installed version coincides with the one in this docs (see bottom left corner of this page).</p><h2 id="ClimArray:-the-core-data-structure"><a class="docs-heading-anchor" href="#ClimArray:-the-core-data-structure"><code>ClimArray</code>: the core data structure</a><a id="ClimArray:-the-core-data-structure-1"></a><a class="docs-heading-anchor-permalink" href="#ClimArray:-the-core-data-structure" title="Permalink"></a></h2><p>This project treats &quot;climate data&quot; as an instance of <a href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimArray</code></a>. At the moment <code>ClimArray</code> is a subtype of <code>DimensionalArray</code> from DimensionalData.jl. A brief introduction to DimensionalData.jl is copied here from its docs, because basic handling of a <code>ClimArray</code> comes from DimensionalData.jl. DimensionalData.jl allows to dimensionally-index data by their values.</p><p>E.g. you can create an array with</p><pre><code class="language-julia">using ClimateBase, Dates
Time = ClimateBase.Ti # `Time` is more intuitive than `Ti`
lats = -90:5:90
lons = 0:10:359
t = Date(2000, 3, 15):Month(1):Date(2020, 3, 15)
# Here we wrap all dimension data into proper dimensions:
dimensions = (Lon(lons), Lat(lats), Time(t))
# where `Lon, Lat, Time` are `Dimension`s exported by ClimateBase
# combining the array data with dimensions makes a `ClimArray`:
data = rand(36, 37, 241) # same size as `dimensions`
A = ClimArray(data, dimensions)</code></pre><pre class="documenter-example-output">ClimArray with dimensions:
  Lon (Longitude): 0:10:350 Sampled: Ordered Regular Points,
  Lat (Latitude): -90:5:90 Sampled: Ordered Regular Points,
  Ti (Time): Dates.Date(&quot;2000-03-15&quot;):Dates.Month(1):Dates.Date(&quot;2020-03-15&quot;)
    Sampled: Ordered Regular Points
and data: 36×37×241 Array{Float64, 3}
[:, :, 1]
 0.611892  0.980786   0.771992   …  0.977224  0.0141651  0.953211
 0.420016  0.766818   0.646983      0.614798  0.695146   0.614558
 0.796038  0.627122   0.276027      0.892204  0.980768   0.280162
 0.174002  0.542387   0.362276      0.778953  0.100369   0.751644
 ⋮                               ⋱            ⋮          
 0.114654  0.205106   0.0513434     0.553254  0.979292   0.0995058
 0.657419  0.0664877  0.851039      0.963636  0.650783   0.542809
 0.619277  0.476705   0.212095      0.392887  0.72557    0.460988
 0.243186  0.345614   0.357263   …  0.788534  0.88669    0.251924
[and 240 more slices...]</pre><p>You can then select a specific time slice at <code>Date(2011,5,15)</code> and a longitude interval between 0 and 30 degrees like so:</p><pre><code class="language-julia">B = A[Lon(Between(0, 30)), Time(At(Date(2011,5,15)))]</code></pre><pre class="documenter-example-output">ClimArray with dimensions:
  Lon (Longitude): 0:10:30 Sampled: Ordered Regular Points,
  Lat (Latitude): -90:5:90 Sampled: Ordered Regular Points
and data: 4×37 Matrix{Float64}
 0.329012  0.391285  0.514997  0.317163   …  0.320584  0.028759   0.373486
 0.614239  0.605925  0.67702   0.642504      0.925346  0.0688725  0.983353
 0.715543  0.503272  0.551875  0.0124002     0.595445  0.581582   0.662662
 0.14664   0.683613  0.577669  0.676705      0.443068  0.320325   0.273315</pre><p>With <code>ClimArray</code> you can use convenience, physically-inspired functions that do automatic (and correct) weighting. For example the latitudinal mean of <code>B</code> is simply</p><pre><code class="language-julia">C = latmean(B)</code></pre><pre class="documenter-example-output">ClimArray with dimensions:
  Lon (Longitude): 0:10:30 Sampled: Ordered Regular Points
and data: 4-element Vector{Float64}
[0.488085, 0.51554, 0.501305, 0.451063]</pre><p>where in this averaging process each data point is weighted by the cosine of its latitude.</p><h3 id="Making-a-ClimArray"><a class="docs-heading-anchor" href="#Making-a-ClimArray">Making a <code>ClimArray</code></a><a id="Making-a-ClimArray-1"></a><a class="docs-heading-anchor-permalink" href="#Making-a-ClimArray" title="Permalink"></a></h3><p>You can create a <code>ClimArray</code> yourself, or you can load data from an <code>.nc</code> file with CF-conventions, see <a href="#NetCDF-IO">NetCDF IO</a>.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}" href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimateBase.ClimArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ClimArray(A::Array, dims::Tuple; name = &quot;&quot;, attrib = nothing)</code></pre><p><code>ClimArray</code> is a structure that contains numerical array data bundled with dimensional information, a name and an <code>attrib</code> field (typically a dictionary) that holds general attributes. You can think of <code>ClimArray</code> as a in-memory representation of a CFVariable.</p><p>At the moment, a <code>ClimArray</code> is using <code>DimensionalArray</code> from DimensionalData.jl, and all basic handling of <code>ClimArray</code> is offered by <code>DimensionalData</code> (see below).</p><p><code>ClimArray</code> is created by passing in standard array data <code>A</code> and a tuple of dimensions <code>dims</code>. See <a href="#ClimateBase.ncread"><code>ncread</code></a> to automatically create a <code>ClimArray</code> from a .nc file.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ClimateBase, Dates
Time = ClimateBase.Ti # more intuitive name for time dimension
lats = -90:5:90
lons = 0:10:359
t = Date(2000, 3, 15):Month(1):Date(2020, 3, 15)
# dimensional information:
dimensions = (Lon(lons), Lat(lats), Time(t))
data = rand(36, 37, 241) # numeric data
A = ClimArray(data, dimensions)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/coredefs.jl#L125-L152">source</a></section></article><p>It is strongly recommended to use the dimensions we export (because we dispatch on them and use their information):</p><pre><code class="language-julia">for D in ClimateBase.STANDARD_DIMS
    println(D, &quot; (full name = $(DimensionalData.name(D)))&quot;)
end</code></pre><pre class="documenter-example-output">Lon (full name = Longitude)
Lat (full name = Latitude)
Ti (full name = Time)
Hei (full name = Height)
Pre (full name = Pressure)
Coord (full name = )</pre><p>We explicitly assume that <code>Lon, Lat</code> are measured in degrees and not radians or meters (extremely important for spatial averaging processes).</p><h2 id="NetCDF-IO"><a class="docs-heading-anchor" href="#NetCDF-IO">NetCDF IO</a><a id="NetCDF-IO-1"></a><a class="docs-heading-anchor-permalink" href="#NetCDF-IO" title="Permalink"></a></h2><p>ClimateBase.jl has support for <code>file.nc ⇆ ClimArray</code>. Usually this is done using NCDatasets.jl, but see below for a function that translates a loaded <code>xarray</code> (from Python) into <code>ClimArray</code>.</p><h3 id="Read"><a class="docs-heading-anchor" href="#Read">Read</a><a id="Read-1"></a><a class="docs-heading-anchor-permalink" href="#Read" title="Permalink"></a></h3><p>To load a <code>ClimArray</code> directly from an <code>.nc</code> file do:</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ncread" href="#ClimateBase.ncread"><code>ClimateBase.ncread</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ncread(file, var; name, kwargs...) → A</code></pre><p>Load the variable <code>var</code> from the <code>file</code> and convert it into a <a href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimArray</code></a> with proper dimension mapping and also containing the variable attributes as a dictionary. Dimension attributes are also given to the dimensions of <code>A</code>, if any exist. See keywords below for specifications for unstructured grids.</p><p><code>file</code> can be a string to a <code>.nc</code> file. Or, it can be an <code>NCDataset</code>, which allows you to lazily combine different <code>.nc</code> data (typically split by time), e.g.</p><pre><code class="language-julia">using Glob # for getting all files
alldata = glob(&quot;toa_fluxes_2020_*.nc&quot;)
file = NCDataset(alldata; aggdim = &quot;time&quot;)
A = ClimArray(file, &quot;tow_sw_all&quot;)</code></pre><p><code>var</code> is a <code>String</code> denoting which variable to load. For <code>.nc</code> data containing groups <code>var</code> can also be a tuple <code>(&quot;group_name&quot;, &quot;var_name&quot;)</code> that loads a specific variable from a specific group. In this case, the attributes of both the group and the CF-variable are attributed to the created <a href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimArray</code></a>.</p><p>See also <a href="#ClimateBase.ncdetails"><code>ncdetails</code></a>, <a href="#ClimateBase.nckeys"><code>nckeys</code></a> and <a href="#ClimateBase.ncwrite"><code>ncwrite</code></a>.</p><p>We do two performance improvements while loading the data:</p><ol><li>If there are no missing values in the data (according to CF standards), the returned array is automatically converted to a concrete type (i.e. <code>Union{Float32, Missing}</code> becomes <code>Float32</code>).</li><li>Dimensions that are ranges (i.e. sampled with constant step size) are automatically transformed to a standard Julia <code>Range</code> type (which makes sub-selecting faster).</li></ol><p><strong>Keywords</strong></p><ul><li><code>name</code> optionally rename loaded array.</li><li><code>grid = nothing</code> optionally specify whether the underlying grid is <code>grid = LonLatGrid()</code> or <code>grid = UnstructuredGrid()</code>, see <a href="#Types-of-spatial-coordinates">Types of spatial coordinates</a>. If <code>nothing</code>, we try to deduce automatically based on the names of dimensions and other keys of the <code>NCDataset</code>.</li><li><code>lon, lat</code>. These two keywords are useful in unstructured grid data where the grid information is provided in a <em>separate .nc file</em>. What we need is the user to provide vectors of the central longitude and central latitude of each grid point. This is done e.g. by<pre><code class="language-julia">ds = NCDataset(&quot;path/to/grid.nc&quot;);
lon = Array(ds[&quot;clon&quot;]);
lat = Array(ds[&quot;clat&quot;]);</code></pre>If <code>lon, lat</code> are given, <code>grid</code> is automatically assumed <code>UnstructuredGrid()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/nc_io.jl#L55-L103">source</a></section></article><p>Notice that (at the moment) we use a pre-defined mapping of common names to proper dimensions - please feel free to extend the following via a Pull Request:</p><pre><code class="language-julia">ClimateBase.COMMONNAMES</code></pre><pre class="documenter-example-output">Dict{String, UnionAll} with 15 entries:
  &quot;lat&quot;       =&gt; Lat
  &quot;altitude&quot;  =&gt; Hei
  &quot;time&quot;      =&gt; Ti
  &quot;pressure&quot;  =&gt; Pre
  &quot;xc&quot;        =&gt; Lon
  &quot;x&quot;         =&gt; Lon
  &quot;lon&quot;       =&gt; Lon
  &quot;level&quot;     =&gt; Pre
  &quot;latitude&quot;  =&gt; Lat
  &quot;height&quot;    =&gt; Hei
  &quot;long&quot;      =&gt; Lon
  &quot;longitude&quot; =&gt; Lon
  &quot;t&quot;         =&gt; Ti
  &quot;yc&quot;        =&gt; Lat
  &quot;y&quot;         =&gt; Lat</pre><p>Also, the following convenience functions are provided for examining the content of on-disk <code>.nc</code> files without loading all data on memory.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.nckeys" href="#ClimateBase.nckeys"><code>ClimateBase.nckeys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nckeys(file::String)</code></pre><p>Return all keys of the <code>.nc</code> file in <code>file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/nc_io.jl#L20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ncdetails" href="#ClimateBase.ncdetails"><code>ClimateBase.ncdetails</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ncdetails(file::String, io = stdout)</code></pre><p>Print details about the <code>.nc</code> file in <code>file</code> on <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/nc_io.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.globalattr" href="#ClimateBase.globalattr"><code>ClimateBase.globalattr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">globalattr(file::String) → Dict</code></pre><p>Return the global attributes of the .nc file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/nc_io.jl#L42-L45">source</a></section></article><h3 id="Write"><a class="docs-heading-anchor" href="#Write">Write</a><a id="Write-1"></a><a class="docs-heading-anchor-permalink" href="#Write" title="Permalink"></a></h3><p>You can also write a bunch of <code>ClimArray</code>s directly into an <code>.nc</code> file with</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ncwrite" href="#ClimateBase.ncwrite"><code>ClimateBase.ncwrite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ncwrite(file::String, Xs; globalattr = Dict())</code></pre><p>Write the given <code>ClimArray</code> instances (any iterable of <code>ClimArray</code>s or a single <code>ClimArray</code>) to a <code>.nc</code> file following CF standard conventions using NCDatasets.jl. Optionally specify global attributes for the <code>.nc</code> file.</p><p>The metadata of the arrays in <code>Xs</code>, as well as their dimensions, are properly written in the <code>.nc</code> file and any necessary type convertions happen automatically.</p><p><strong>WARNING</strong>: We assume that any dimensions shared between the <code>Xs</code> are identical.</p><p>See also <a href="#ClimateBase.ncread"><code>ncread</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/nc_io.jl#L375-L387">source</a></section></article><h3 id="xarray"><a class="docs-heading-anchor" href="#xarray">xarray</a><a id="xarray-1"></a><a class="docs-heading-anchor-permalink" href="#xarray" title="Permalink"></a></h3><p>You can use the following functions (which are not defined and exported in <code>ClimateBase</code> to avoid dependency on PyCall.jl) to load data using Python&#39;s <code>xarray</code>.</p><pre><code class="language-julia">using ClimateBase, Dates
# This needs to numpy, xarray and dask installed from Conda
using PyCall
xr = pyimport(&quot;xarray&quot;)
np = pyimport(&quot;numpy&quot;)

function climarray_from_xarray(xa, fieldname, name = fieldname)
    w = getproperty(xa, Symbol(fieldname))
    raw_data = Array(w.values)
    dnames = collect(w.dims) # dimensions in string name
    dim_values, dim_attrs = extract_dimension_values_xarray(xa, dnames)
    @assert collect(size(raw_data)) == length.(dim_values)
    actual_dims = create_dims_xarray(dnames, dim_values, dim_attrs)
    ca = ClimArray(raw_data, actual_dims, name; attrib = w.attrs)
end

function extract_dimension_values_xarray(xa, dnames = collect(xa.dims))
    dim_values = []
    dim_attrs = Vector{Any}(fill(nothing, length(dnames)))
    for (i, d) in enumerate(dnames)
        dim_attrs[i] = getproperty(xa, d).attrs
        x = getproperty(xa, d).values
        if d ≠ &quot;time&quot;
            push!(dim_values, x)
        else
            dates = [np.datetime_as_string(y)[1:19] for y in x]
            dates = DateTime.(dates)
            push!(dim_values, dates)
        end
    end
    return dim_values, dim_attrs
end

function create_dims_xarray(dnames, dim_values, dim_attrs)
    true_dims = ClimateBase.to_proper_dimensions(dnames)
    optimal_values = ClimateBase.vector2range.(dim_values)
    out = []
    for i in 1:length(true_dims)
        push!(out, true_dims[i](optimal_values[i]; metadata = dim_attrs[i]))
    end
    return (out...,)
end

# Load some data
xa = xr.open_mfdataset(ERA5_files_path)
X = climarray_from_xarray(xa, &quot;w&quot;, &quot;optional name&quot;)</code></pre><h2 id="Temporal"><a class="docs-heading-anchor" href="#Temporal">Temporal</a><a id="Temporal-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal" title="Permalink"></a></h2><p>Functions related with the <code>Time</code> dimension.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.timemean" href="#ClimateBase.timemean"><code>ClimateBase.timemean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timemean(A::ClimArray [, w]) = timeagg(mean, A, w)</code></pre><p>Temporal average of <code>A</code>, see <a href="#ClimateBase.timeagg"><code>timeagg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L220-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.timeagg" href="#ClimateBase.timeagg"><code>ClimateBase.timeagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timeagg(f, A::ClimArray, W = nothing)</code></pre><p>Perform a proper temporal aggregation of the function <code>f</code> (e.g. <code>mean, std</code>) on <code>A</code> where:</p><ul><li>Only full year spans of <code>A</code> are included, see <a href="#ClimateBase.maxyearspan"><code>maxyearspan</code></a> (because most processes are affected by yearly cycle, and averaging over an uneven number of cycles typically results in artifacts)</li><li>Each month in <code>A</code> is weighted with its length in days (for monthly sampled data)</li></ul><p>If you don&#39;t want these features, just do <a href="#ClimateBase.dropagg"><code>dropagg</code></a><code>(f, A, Time, W)</code>. This is also done in the case where the time sampling is unknown.</p><p><code>W</code> are possible statistical weights that are used in conjuction to the temporal weighting, to weight each time point differently. If they are not a vector (a weight for each time point), then they have to be a dimensional array of same dimensional layout as <code>A</code> (a weight for each data point).</p><p>See also <a href="#ClimateBase.monthlyagg"><code>monthlyagg</code></a>, <a href="#ClimateBase.yearlyagg"><code>yearlyagg</code></a>, <a href="#ClimateBase.seasonalyagg"><code>seasonalyagg</code></a>.</p><pre><code class="nohighlight">timeagg(f, t::Vector, x::Vector, w = nothing)</code></pre><p>Same as above, but for arbitrary vector <code>x</code> accompanied by time vector <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L227-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.monthlyagg" href="#ClimateBase.monthlyagg"><code>ClimateBase.monthlyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">monthlyagg(A::ClimArray, f = mean; mday = 15) -&gt; B</code></pre><p>Create a new array where the temporal information has been aggregated into months using the function <code>f</code>. The dates of the new array always have day number of <code>mday</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L340-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.yearlyagg" href="#ClimateBase.yearlyagg"><code>ClimateBase.yearlyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yearlyagg(A::ClimArray, f = mean) -&gt; B</code></pre><p>Create a new array where the temporal information has been aggregated into years using the function <code>f</code>. By convention, the dates of the new array always have month and day number of <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L355-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.seasonalyagg" href="#ClimateBase.seasonalyagg"><code>ClimateBase.seasonalyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seasonalyagg(A::ClimArray, f = mean) -&gt; B</code></pre><p>Create a new array where the temporal information has been aggregated into seasons using the function <code>f</code>. By convention, seasons are represented as Dates spaced 3-months apart, where only the months December, March, June and September are used to specify the date, with day 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L407-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.temporalrange" href="#ClimateBase.temporalrange"><code>ClimateBase.temporalrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">temporalrange(A::ClimArray, f = Dates.month) → r
temporalrange(t::AbstractVector{&lt;:TimeType}}, f = Dates.month) → r</code></pre><p>Return a vector of ranges so that each range of indices are values of <code>t</code> that belong in either the same month, year, day, or season, depending on <code>f</code>. <code>f</code> can take the values: <code>Dates.year, Dates.month, Dates.day</code> or <code>season</code> (all are functions).</p><p>Used in e.g. <a href="#ClimateBase.monthlyagg"><code>monthlyagg</code></a>, <a href="#ClimateBase.yearlyagg"><code>yearlyagg</code></a> or <a href="#ClimateBase.seasonalyagg"><code>seasonalyagg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L380-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.maxyearspan" href="#ClimateBase.maxyearspan"><code>ClimateBase.maxyearspan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maxyearspan(A::ClimArray) = maxyearspan(dims(A, Time))
maxyearspan(t::Vector{&lt;:DateTime}) → i</code></pre><p>Find the maximum index <code>i</code> of <code>t</code> so that <code>t[1:i]</code> covers exact(*) multiples of years.</p><p>(*) For monthly spaced data <code>i</code> is a multiple of <code>12</code> while for daily data we find the largest possible multiple of <code>DAYS_IN_ORBIT</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L82-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.temporal_sampling" href="#ClimateBase.temporal_sampling"><code>ClimateBase.temporal_sampling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">temporal_sampling(x) → symbol</code></pre><p>Return the temporal sampling type of <code>x</code>, which is either an array of <code>Date</code>s or a dimensional array (with <code>Time</code> dimension).</p><p>Possible return values are:</p><ul><li><code>:hourly</code>, where the temporal difference between successive entries is exactly 1 hour.</li><li><code>:daily</code>, where the temporal difference between successive entries is exactly 1 day.</li><li><code>:monthly</code>, where all dates have the same day, but different month.</li><li><code>:yearly</code>, where all dates have the same month and day, but different year.</li><li><code>:other</code>, which means that <code>x</code> doesn&#39;t fall to any of the above categories.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L25-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.realtime_days" href="#ClimateBase.realtime_days"><code>ClimateBase.realtime_days</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">realtime_days(t::AbstractVector{&lt;:TimeType}, T = Float32)</code></pre><p>Convert the given <em>sequential</em> date time vector <code>t</code> in a vector in a format of &quot;real time&quot;, where time is represented by real numbers, increasing cumulatively, as is the case when representing a timeseries <code>x(t)</code>. As only differences matter in this form, the returned vector always starts from 0. The measurement unit of time here is days.</p><p>For temporal sampling less than daily return <code>realtime_milliseconds(t) ./ (24*60*60*1000)</code>.</p><p>Example:</p><pre><code class="language-juliarepl">julia&gt; t = Date(2004):Month(1):Date(2004, 6)
Date(&quot;2004-01-01&quot;):Month(1):Date(&quot;2004-06-01&quot;)

julia&gt; realtime_days(t)
6-element Vector{Float32}:
   0.0
  29.0
  60.0
  90.0
 121.0
 151.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L161-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.realtime_milliseconds" href="#ClimateBase.realtime_milliseconds"><code>ClimateBase.realtime_milliseconds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">realtime_milliseconds(t::AbstractArray{&lt;:TimeType}, T = Float64)</code></pre><p>Similar with <a href="#ClimateBase.realtime_days"><code>realtime_days</code></a>, but now the measurement unit is millisecond. For extra accuracy, direct differences in <code>t</code> are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L203-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.seasonality" href="#ClimateBase.seasonality"><code>ClimateBase.seasonality</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seasonality(t, x; y0 = year(t[1])) → dates, vals</code></pre><p>Calculate the &quot;seasonality&quot; of a vector <code>x</code> defined with respect to a datetime vector <code>t</code> and return <code>dates, vals</code>. <code>dates</code> are all unique dates present in <code>t</code> <em>disregarding the year</em> (so only the month and day are compared). The <code>dates</code> have as year entry <code>y0</code>. <code>vals</code> is a vector of vectors, where <code>vals[i]</code> are all the values of <code>x</code> that have day and month same as <code>dates[i]</code>. The elements of <code>vals</code> are sorted as encountered in <code>x</code>.</p><p>Typically one is interested in <code>mean.(vals)</code>, which actually is the seasonality, and <code>std.(vals)</code> which is the interannual variability at each date.</p><pre><code class="nohighlight">seasonality(A::ClimArray) → dates, vals</code></pre><p>If given a <code>ClimArray</code>, then the array must have only one dimension (time).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/temporal.jl#L459-L473">source</a></section></article><h2 id="Spatial"><a class="docs-heading-anchor" href="#Spatial">Spatial</a><a id="Spatial-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial" title="Permalink"></a></h2><p>All functions in this section work for both types of space, see <a href="#Types-of-spatial-coordinates">Types of spatial coordinates</a>.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.zonalmean" href="#ClimateBase.zonalmean"><code>ClimateBase.zonalmean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">zonalmean(A::ClimArray [, W])</code></pre><p>Return the zonal mean of <code>A</code>. Works for both <a href="#ClimateBase.LonLatGrid"><code>LonLatGrid</code></a> as well as <a href="#ClimateBase.UnstructuredGrid"><code>UnstructuredGrid</code></a>. Optionally provide statistical weights <code>W</code>. These can be the same <code>size</code> as <code>A</code> or only having the same latitude structure as <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/spatial.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.latmean" href="#ClimateBase.latmean"><code>ClimateBase.latmean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">latmean(A::ClimArray)</code></pre><p>Return the latitude-mean <code>A</code> (mean across dimension <code>Lat</code>). This function properly weights by the cosine of the latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/spatial.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spacemean" href="#ClimateBase.spacemean"><code>ClimateBase.spacemean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spacemean(A::ClimArray [, W]) = spaceagg(mean, A, W)</code></pre><p>Average given <code>A</code> over its spatial coordinates. Optionally provide statistical weights in <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/spatial.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spaceagg" href="#ClimateBase.spaceagg"><code>ClimateBase.spaceagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spaceagg(f, A::ClimArray, W = nothing)</code></pre><p>Aggregate <code>A</code> using function <code>f</code> (e.g. <code>mean, std</code>) over all available space (i.e. longitude and latitude) of <code>A</code>, weighting every part of <code>A</code> by its spatial area.</p><p><code>W</code> can be extra weights, to weight each spatial point with. <code>W</code> can either be a <code>ClimArray</code> with same spatial information as <code>A</code>, or having exactly same dimensions as <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/spatial.jl#L131-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.hemispheric_means" href="#ClimateBase.hemispheric_means"><code>ClimateBase.hemispheric_means</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hemispheric_means(A) → nh, sh</code></pre><p>Return the (proper) averages of <code>A</code> over the northern and southern hemispheres. Notice that this function explicitly does both zonal as well as meridional averaging. Use <a href="#ClimateBase.hemispheric_functions"><code>hemispheric_functions</code></a> to just split <code>A</code> into two hemispheres.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/spatial.jl#L214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.hemispheric_functions" href="#ClimateBase.hemispheric_functions"><code>ClimateBase.hemispheric_functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hemispheric_functions(A::ClimArray) → north, south</code></pre><p>Return two arrays <code>north, south</code>, by splitting <code>A</code> to its northern and southern hemispheres, appropriately translating the latitudes of <code>south</code> so that both arrays have the same latitudinal dimension (and thus can be compared and do opperations between them).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/spatial.jl#L195-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.tropics_extratropics" href="#ClimateBase.tropics_extratropics"><code>ClimateBase.tropics_extratropics</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tropics_extratropics(A::ClimArray) → tropics, extratropics</code></pre><p>Separate the given array into two arrays: one having latitudes ℓ ∈ [-30, 30], and one having all other remaining latitudes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/spatial.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.lonlatfirst" href="#ClimateBase.lonlatfirst"><code>ClimateBase.lonlatfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lonlatfirst(A::ClimArray, args...) → B</code></pre><p>Permute the dimensions of <code>A</code> to make a new array <code>B</code> that has first dimension longitude, second dimension latitude, with the remaining dimensions of <code>A</code> following (useful for most plotting functions). Optional extra dimensions can be given as <code>args...</code>, specifying a specific order for the remaining dimensions.</p><p>Example:</p><pre><code class="language-julia">B = lonlatfirst(A)
C = lonlatfirst(A, Time)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/spatial.jl#L30-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.longitude_circshift" href="#ClimateBase.longitude_circshift"><code>ClimateBase.longitude_circshift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">longitude_circshift(X::ClimArray, l = size(X, Lon)÷2, wrap = false)</code></pre><p>Perform the same action as <code>Base.circshift</code>, but only for the longitudinal dimension of <code>X</code> with shift <code>l</code>. If <code>wrap = true</code> the longitudes are wrapped to (-180, 180) degrees.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/spatial.jl#L67-L71">source</a></section></article><h3 id="Types-of-spatial-coordinates"><a class="docs-heading-anchor" href="#Types-of-spatial-coordinates">Types of spatial coordinates</a><a id="Types-of-spatial-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-spatial-coordinates" title="Permalink"></a></h3><p>At the moment the following type of spatial coordinates are supported:</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.LonLatGrid" href="#ClimateBase.LonLatGrid"><code>ClimateBase.LonLatGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Space coordinates are represented by two orthogonal dimensions <code>Lon, Lat</code>, one being longitude and the other being latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/coredefs.jl#L63-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.UnstructuredGrid" href="#ClimateBase.UnstructuredGrid"><code>ClimateBase.UnstructuredGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Space coordinates are represented by a single dimension <code>Coord</code>, whose elements are coordinate locations, i.e. 2-element <code>SVector(longitude, latitude)</code>. Each coordinate represents an <strong>equal area polygon</strong> corresponding to the point in space. The actual limits of each polygon are not included in the dimension for performance reasons.</p><p>This dimension allows indexing according to the underlying <code>Lon, Lat</code> representation, e.g. you can do</p><pre><code class="language-julia">A # some `ClimArray` with unstructured grid type.
A[Coord(Lon(Between(0, 30)), Lat(Between(-30, 30)))]</code></pre><p>To use functions such as <a href="#ClimateBase.zonalmean"><code>zonalmean</code></a> or <a href="#ClimateBase.hemispheric_means"><code>hemispheric_means</code></a> with this grid, you must first sort the <code>ClimArray</code> so that the latitudes of its coordinates are sorted in ascending order. I.e.</p><pre><code class="language-julia">A # some `ClimArray` with unstructured grid type.
coords = dims(A, Coord).val
si = sortperm(coords, by = reverse)
A = A[Coord(si)]</code></pre><p><strong>This is done automatically by <a href="#ClimateBase.ncread"><code>ncread</code></a>.</strong></p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p><code>UnstructuredGrid</code> functionality is currently in an <strong>experimental phase</strong>! Notice that non-equal area unstructured grids are not supported yet.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/coredefs.jl#L69-L96">source</a></section></article><p>ClimateBase.jl works with either type of spatial coordinate system. Therefore, physically inspired averaging functions, like <a href="#ClimateBase.spacemean"><code>spacemean</code></a> or <a href="#ClimateBase.zonalmean"><code>zonalmean</code></a>, work for both types of spatial coordinates. In addition, the function <code>spatialidxs</code> returns an iterator over the spatial coordinates of the data, and works for both types (grid or equal-area):</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spatialidxs" href="#ClimateBase.spatialidxs"><code>ClimateBase.spatialidxs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spatialidxs(A::ClimArray) → idxs</code></pre><p>Return an iterable that can be used to access all spatial points of <code>A</code> with the syntax</p><pre><code class="language-julia">idxs = spatialidxs(A)
for i in idxs
    slice_at_give_space_point = A[i...]
end</code></pre><p>Works for all types of space (<code>...</code> is necessary because <code>i</code> is a <code>Tuple</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/physical_dimensions/spatial.jl#L12-L22">source</a></section></article><p><a href="#ClimateBase.ncread"><code>ncread</code></a> tries to automatically deduce the correct space type and create the appropriate dimension.</p><h2 id="General-aggregation"><a class="docs-heading-anchor" href="#General-aggregation">General aggregation</a><a id="General-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#General-aggregation" title="Permalink"></a></h2><p>The physical averages of the previous section are done by taking advantage of a general aggregation syntax, which works with any aggregating function like <code>mean, sum, std</code>, etc.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.dropagg" href="#ClimateBase.dropagg"><code>ClimateBase.dropagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropagg(f, A, d [, W])</code></pre><p>Apply statistics/aggregating function <code>f</code> (e.g. <code>sum</code> or <code>mean</code>) on array <code>A</code> across dimension(s) <code>d</code> and drop the corresponding dimension(s) from the result (Julia inherently keeps singleton dimensions).</p><p>If <code>A</code> is one dimensional, <code>dropagg</code> will return the single number of applying <code>f(A)</code>.</p><p>Optionally you can provide statistical weights in the form of an array <code>W</code>. <code>W</code> must have same size as <code>A</code>. An exception is when <code>d</code> is only a single dimension, e.g. <code>d = Lat</code>; then <code>W</code> is also allowed to be a single vector with length the same as <code>dims(A, d)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/aggregation.jl#L64-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.collapse" href="#ClimateBase.collapse"><code>ClimateBase.collapse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collapse(f, A, dim)</code></pre><p>Reduce <code>A</code> towards dimension <code>dim</code> using the collapsing function <code>f</code> (e.g. <code>mean</code>). This means that <code>f</code> is applied across all other dimensions of <code>A</code>, each of which are subsequently dropped, leaving only the collapsed result of <code>A</code> vs. the remaining dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/aggregation.jl#L109-L114">source</a></section></article><h2 id="Missing-data"><a class="docs-heading-anchor" href="#Missing-data">Missing data</a><a id="Missing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-data" title="Permalink"></a></h2><p>When loading an array with <a href="#ClimateBase.ncread"><code>ncread</code></a>, the values of the return array may contain missing values if the actual data contain missing values according to the CF-standards. In other packages or other programming languages these missing values are handled &quot;internally&quot; and e.g. in statistical operations like <code>mean</code>, the statistics explicitly skip over missing values. For example this is a typical workflow of creating an array, assigning <code>missing</code> to all values of an array over land, and then taking the <code>mean</code> of the array, which would be the &quot;mean over ocean&quot;.</p><p>ClimateBase.jl <em>does not</em> follow this approach for two reasons: 1) it does not comply with <a href="https://docs.julialang.org/en/v1/manual/missing/">Julia&#39;s <code>missing</code> propagation logic</a>, 2) using proper statistical weights gives more power to the user. As you have already seen in the documentation strings of e.g. <a href="#ClimateBase.timeagg"><code>timeagg</code></a>, <a href="#ClimateBase.spaceagg"><code>spaceagg</code></a> or <a href="#ClimateBase.dropagg"><code>dropagg</code></a>, you can provide explicit statistical weights of various forms. This gives you more power, because in the case of <code>missing</code> your statistical weights can only be 0 (missing value) or 1 (non-missing value). As an example, &quot;pixel&quot; of your spatial grid will have ambiguous values if it is not 100% covered by ocean, and to do a <em>proper</em> average over ocean you should instead provide weights <code>W</code> whose value is quite simply the ocean fraction of each pixel.</p><p>But what if you already have an array with <code>missing</code> values and you want to do what was described in the beginning, e.g. average by skipping the missings? Do not worry, we have you covered! Use the function <a href="#ClimateBase.missing_weights"><code>missing_weights</code></a>! See also <a href="#ClimateBase.sinusoidal_continuation"><code>sinusoidal_continuation</code></a> if the missing values are only in a subset of your temporal coverage.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.missing_weights" href="#ClimateBase.missing_weights"><code>ClimateBase.missing_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">missing_weights(A::ClimArray, val = missing_val(A)) → B, W</code></pre><p>Generate a new array <code>B</code> with values like <code>A</code>, but with <code>A</code>&#39;s <code>missing</code> values replaced with <code>val</code>. Also generate an array of weights, which has the value 0 when <code>A</code> had <code>missing</code>, and the value <code>1</code> otherwise.</p><p>The output of this function should be used in conjunction with any of ClimateBase.jl aggregating functions like <code>spacemean, timemean, ...</code>, when your data have <code>missing</code> values which you want to <em>completely skip</em> during the aggregation process.</p><p>This function returns <code>A, nothing</code> if <code>A</code> has no <code>missing</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/aggregation.jl#L17-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.missing_val" href="#ClimateBase.missing_val"><code>ClimateBase.missing_val</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">missing_val(A)</code></pre><p>Return the value that represents &quot;missing&quot; data in <code>A</code>, according to <code>A</code>&#39;s metadata. If <code>A</code> does not have the <code>_FillValue</code> metadata, return 0 instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/core/aggregation.jl#L42-L46">source</a></section></article><h2 id="Timeseries-Analysis"><a class="docs-heading-anchor" href="#Timeseries-Analysis">Timeseries Analysis</a><a id="Timeseries-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Timeseries-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.sinusoidal_continuation" href="#ClimateBase.sinusoidal_continuation"><code>ClimateBase.sinusoidal_continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sinusoidal_continuation(T::ClimArray, fs = [1, 2]; Tmin = -Inf, Tmax = Inf)</code></pre><p>Fill-in the missing values of spatiotemporal field <code>T</code>, by fitting sinusoidals to the non-missing values, and then using the fitted sinusoidals for the missing values.</p><p>Frequencies are given per year (frequency 2 means 1/2 of a year).</p><p><code>Tmin, Tmax</code> limits are used to clamp the result into this range (no clamping in the default case).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/tsa/continuation.jl#L15-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.seasonal_decomposition" href="#ClimateBase.seasonal_decomposition"><code>ClimateBase.seasonal_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seasonal_decomposition(A::ClimArray, fs = [1, 2]) → seasonal, residual</code></pre><p>Decompose <code>A</code> into a seasonal and residual components, where the seasonal contains the periodic parts of <code>A</code>, with frequencies given in <code>fs</code>, and residual contains what&#39;s left.</p><p><code>fs</code> is measured in 1/year. This function works even for non-equispaced time axis (e.g. monthly averages) and uses LPVSpectral.jl and SignalDecomposition.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/tsa/decomposition.jl#L5-L12">source</a></section></article><h2 id="Climate-quantities"><a class="docs-heading-anchor" href="#Climate-quantities">Climate quantities</a><a id="Climate-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Climate-quantities" title="Permalink"></a></h2><p>Functions that calculate climate-related quantities.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.insolation" href="#ClimateBase.insolation"><code>ClimateBase.insolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insolation(t, ϕ; kwargs...)</code></pre><p>Calculate daily averaged insolation in W/m² at given time and latitude <code>t, φ</code>. <code>φ</code> is given in <strong>degrees</strong>, and <code>t</code> in <strong>days</strong> (real number or date).</p><p>Keywords:</p><pre><code class="nohighlight">Ya = DAYS_IN_ORBIT # = 365.26 # days
t_VE = 76.0 # days of vernal equinox
S_0 = 1362.0 # W/m^2
γ=23.44
ϖ=282.95
e=0.017 # eccentricity</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/climate/solar.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.surface_atmosphere_contributions" href="#ClimateBase.surface_atmosphere_contributions"><code>ClimateBase.surface_atmosphere_contributions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">surface_atmosphere_contributions(I, F_toa_⬆, F_s_⬆, F_s_⬇) → α_ATM, α_SFC</code></pre><p>Calculate the atmospheric and surface <strong>contributions</strong> of the planetary albedo, so that the TOA albedo is <code>α = α_ATM + α_SFC</code>, using the simple 1-layer radiative transfer model by Donohoe &amp; Battisti (2011) or G. Stephens (2015). Stephens&#39; formulas are incorrect and I have corrected them!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/climate/albedo.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.total_toa_albedo" href="#ClimateBase.total_toa_albedo"><code>ClimateBase.total_toa_albedo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">total_toa_albedo(a, s, t) = a + s*t^2/(1-a*s)</code></pre><p>Combine given atmosphere albedo <code>a</code>, surface albedo <code>s</code> and atmosphere transmittance <code>t</code> into a total top-of-the-atmosphere albedo <code>α</code> according to the model of Donohoe &amp; Battisti (2011).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/fcdca893100210c929659cf506a19b85cd53c598/src/climate/albedo.jl#L30-L34">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>Currently ClimateBase.jl does not have integrated plotting support. In the near future it will have this based on the upcoming GeoMakie.jl.</p><p>For now, you can use PyCall.jl, matplotlib, and the Python library cartopy. In the file <a href="https://github.com/JuliaClimate/ClimateBase.jl/tree/master/plotting/python.jl"><code>ClimateBase/plotting/python.jl</code></a> we provide two functions that plot maps of <code>ClimArray</code> in arbitrary projections: <code>earthsurface</code> for <code>LonLatGrid</code> and <code>earthscatter</code> for <code>UnstructuredGrid</code>. You can incorporate these in your source code as a temporary solution.</p><h2 id="Ensemble-types"><a class="docs-heading-anchor" href="#Ensemble-types">Ensemble types</a><a id="Ensemble-types-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-types" title="Permalink"></a></h2><p>A dedicated type representing ensembles has no reason to exist in ClimateBase.jl. As the package takes advantage of standard Julia datastructures and syntax, those can be used to represent &quot;ensembles&quot;. For example to do an &quot;ensemble global mean&quot; you can just do:</p><pre><code class="language-julia">E = [ClimArray(&quot;ensemble_$i.nc&quot;, &quot;x&quot;) for i in 1:10]
global_mean = mean(spacemean(X) for X in E)</code></pre><p>where you see that the &quot;ensemble&quot; was represented just as a <code>Vector{ClimArray}</code>.</p><h2 id="Crash-course-to-DimensionalData.jl"><a class="docs-heading-anchor" href="#Crash-course-to-DimensionalData.jl">Crash-course to DimensionalData.jl</a><a id="Crash-course-to-DimensionalData.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Crash-course-to-DimensionalData.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData" href="#DimensionalData"><code>DimensionalData</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>DimensionalData</strong></p><p><a href="https://rafaqz.github.io/DimensionalData.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://rafaqz.github.io/DimensionalData.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <img src="https://github.com/rafaqz/DimensionalData.jl/workflows/CI/badge.svg" alt="CI"/> <a href="https://codecov.io/gh/rafaqz/DimensionalData.jl"><img src="https://codecov.io/gh/rafaqz/DimensionalData.jl/branch/master/graph/badge.svg" alt="Codecov"/></a> <a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://img.shields.io/badge/Aqua.jl-%F0%9F%8C%A2-aqua.svg" alt="Aqua.jl Quality Assurance"/></a></p><p>DimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions, and optionally a lookup index. It&#39;s a pluggable,  generalised version of <a href="https://github.com/JuliaArrays/AxisArrays.jl">AxisArrays.jl</a>  with a cleaner syntax, and additional functionality found in NamedDims.jl. It has  similar goals to pythons <a href="http://xarray.pydata.org/en/stable/">xarray</a>, and is primarily written for use with spatial data in <a href="https://github.com/rafaqz/GeoData.jl">GeoData.jl</a>.</p><p>Broadcasting and most Base methods maintain and sync dimension context.</p><p>DimensionalData.jl also implements:</p><ul><li>comprehensive plot recipes for Plots.jl.</li><li>a Tables.jl interface with <code>DimTable</code></li><li>multi-layered <code>DimStack</code>s that can be indexed together,    and have base methods applied to all layers.</li><li>the Adapt.jl interface for use on GPUs, even as GPU kernel arguments.</li><li>traits for handling a wide range of spatial data types accurately.</li></ul><p><strong>Dimensions</strong></p><p>Dimensions are wrapper types. They hold the lookup index, details about the  grid, and other metadata. They are also used to index into the array.  <code>X</code>, <code>Y</code>, <code>Z</code> and <code>Ti</code> are the exported defaults. A generalised <code>Dim</code> type is available  to use arbitrary symbols to name dimensions. Custom dimension types can also be defined  using the <code>@dim</code> macro.</p><p>Dimensions can be used to construct arrays in <code>rand</code>, <code>ones</code>, <code>zeros</code> and <code>fill</code> with  either a range for a lookup index or a number for the dimension length:</p><pre><code class="language-julia">julia&gt; using DimensionalData

julia&gt; A = rand(X(1:40), Y(50))
40×50 DimArray{Float64,2} with dimensions:
  X: 1:40 (Sampled - Ordered Regular Points)
  Y
 0.929006   0.116946  0.750017  …  0.172604  0.678835   0.495294
 0.0550038  0.100739  0.427026     0.778067  0.309657   0.831754
 ⋮                              ⋱
 0.647768   0.965682  0.049315     0.220338  0.0326206  0.36705
 0.851769   0.164914  0.555637     0.771508  0.964596   0.30265</code></pre><p>We can also use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:</p><pre><code class="language-julia">julia&gt; A[Y(1), X(1:10)]
10-element DimArray{Float64,1} with dimensions:
  X: 1:10 (Sampled - Ordered Regular Points)
and reference dimensions: Y(1) 
 0.929006
 0.0550038
 0.641773
 ⋮
 0.846251
 0.506362
 0.0492866</code></pre><p>And this has no runtime cost:</p><pre><code class="language-julia">julia&gt; A = ones(X(3), Y(3))
3×3 DimArray{Float64,2} with dimensions: X, Y
 1.0  1.0  1.0
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; @btime $A[X(1), Y(2)]
  1.077 ns (0 allocations: 0 bytes)
1.0

julia&gt; @btime parent($A)[1, 2]
  1.078 ns (0 allocations: 0 bytes)
1.0</code></pre><p>Dims can be used for indexing and views without knowing dimension order:</p><pre><code class="language-julia">julia&gt; A = rand(X(40), Y(50))
40×50 DimArray{Float64,2} with dimensions: X, Y
 0.377696  0.105445  0.543156  …  0.844973  0.163758  0.849367
 ⋮                             ⋱
 0.431454  0.108927  0.137541     0.531587  0.592512  0.598927

julia&gt; A[Y=3]
40-element DimArray{Float64,1} with dimensions: X
and reference dimensions: Y(3)
 0.543156
 ⋮
 0.137541

julia&gt; view(A, Y(), X(1:5))
5×50 DimArray{Float64,2} with dimensions: X, Y
 0.377696  0.105445  0.543156  …  0.844973  0.163758  0.849367
 ⋮                             ⋱
 0.875279  0.133032  0.925045     0.156768  0.736917  0.444683</code></pre><p>And for specifying dimension number in all <code>Base</code> and <code>Statistics</code>  functions that have a <code>dims</code> argument:</p><pre><code class="language-julia">julia&gt; using Statistics

julia&gt; A = rand(X(3), Y(4), Ti(5));

julia&gt; mean(A; dims=Ti)
3×4×1 DimArray{Float64,3} with dimensions: X, Y, Ti (Time)
[:, :, 1]
 0.168058  0.52353   0.563065  0.347025
 0.472786  0.395884  0.307846  0.518926
 0.365028  0.381367  0.423553  0.369339</code></pre><p>You can also use symbols to create <code>Dim{X}</code> dimensions, although we can&#39;t use the <code>rand</code> method directly with Symbols, and insteadd use the regular <code>DimArray</code> constructor:</p><pre><code class="language-julia">julia&gt; A = DimArray(rand(10, 20, 30), (:a, :b, :c));

julia&gt; A[a=2:5, c=9]

4×20 DimArray{Float64,2} with dimensions: Dim{:a}, Dim{:b}
and reference dimensions: Dim{:c}(9)
 0.134354  0.581673  0.422615  …  0.410222   0.687915  0.753441
 0.573664  0.547341  0.835962     0.0353398  0.794341  0.490831
 0.166643  0.133217  0.879084     0.695685   0.956644  0.698638
 0.325034  0.147461  0.149673     0.560843   0.889962  0.75733</code></pre><p><strong>Selectors</strong></p><p>Selectors find indices in the lookup index for each dimension: </p><ul><li><code>At(x)</code>: get the index exactly matching the passed in value(s)</li><li><code>Near(x)</code>: get the closest index to the passed in value(s)</li><li><code>Where(f::Function)</code>: filter the array axis by a function of the    dimension index values.</li><li><code>Between(a, b)</code>: get all indices between two values, excluding the high value.</li><li><code>Contains(x)</code>: get indices where the value x falls within the interval, exluding    the upper value. Only used for <code>Sampled</code> <code>Intervals</code>, for <code>Points</code>, use <code>At</code>.</li></ul><p>(<code>Between</code> and <code>Contains</code> exlude the upper boundary so that adjacent selections never contain the same index)</p><p>Selectors can be used in <code>getindex</code>, <code>setindex!</code> and <code>view</code> to select indices matching the passed in value(s)</p><p>We can use selectors inside dim wrappers:</p><pre><code class="language-julia">julia&gt; using Dates

julia&gt; timespan = DateTime(2001,1):Month(1):DateTime(2001,12)
DateTime(&quot;2001-01-01T00:00:00&quot;):Month(1):DateTime(&quot;2001-12-01T00:00:00&quot;)

julia&gt; A = DimArray(rand(12,10), (Ti(timespan), X(10:10:100)))
12×10 DimArray{Float64,2} with dimensions:
  Ti (Time): DateTime(&quot;2001-01-01T00:00:00&quot;):Month(1):DateTime(&quot;2001-12-01T00:00:00&quot;) (Sampled - Ordered Regular Points)
  X: 10:10:100 (Sampled - Ordered Regular Points)
 0.14106   0.476176  0.311356  0.454908  …  0.464364  0.973193  0.535004
 ⋮                                       ⋱
 0.522759  0.390414  0.797637  0.686718     0.901123  0.704603  0.0740788

julia&gt; @btime A[X(Near(35)), Ti(At(DateTime(2001,5)))]
0.3133109280208961</code></pre><p>Without dim wrappers selectors must be in the right order:</p><pre><code class="language-julia">using Unitful

julia&gt; A = rand(X((1:10:100)u&quot;m&quot;), Ti((1:5:100)u&quot;s&quot;));

julia&gt; A[Between(10.5u&quot;m&quot;, 50.5u&quot;m&quot;), Near(23u&quot;s&quot;)]
4-element DimArray{Float64,1} with dimensions:
  X: (11:10:41) m (Sampled - Ordered Regular Points)
and reference dimensions:
  Ti(21 s) (Time): 21 s (Sampled - Ordered Regular Points)
 0.584028
 ⋮
 0.716715</code></pre><p>For values other than <code>Int</code>/<code>AbstractArray</code>/<code>Colon</code> (which are set aside for regular indexing) the <code>At</code> selector is assumed, and can be dropped completely:</p><pre><code class="language-julia">julia&gt; A = rand(X([:a, :b, :c]), Y([25.6, 25.7, 25.8]));

julia&gt; A[:b, 25.8]
0.61839141062599</code></pre><p><strong>Compile-time selectors</strong></p><p>Using all <code>Val</code> indexes (only recommended for small arrays) you can index with named dimensions <code>At</code> arbitrary values with no runtime cost:</p><pre><code class="language-julia">julia&gt; A = rand(X(Val((:a, :b, :c))), Y(Val((5.0, 6.0, 7.0))))
3×3 DimArray{Float64,2} with dimensions:
  X: Val{(:a, :b, :c)}() (Categorical - Unordered)
  Y: Val{(5.0, 6.0, 7.0)}() (Categorical - Unordered)
 0.5808   0.835037  0.528461
 0.8924   0.431394  0.506915
 0.66386  0.955305  0.774132

julia&gt; @btime $A[:c, 6.0]
  2.777 ns (0 allocations: 0 bytes)
0.9553052910459472

julia&gt; @btime $A[Val(:c), Val(6.0)]
  1.288 ns (0 allocations: 0 bytes)
0.9553052910459472</code></pre><p><strong>Methods where dims can be used containing indices or Selectors</strong></p><p><code>getindex</code>, <code>setindex!</code> <code>view</code></p><p><strong>Methods where dims, dim types, or <code>Symbol</code>s can be used to indicate the array dimension:</strong></p><ul><li><code>size</code>, <code>axes</code>, <code>firstindex</code>, <code>lastindex</code></li><li><code>cat</code>, <code>reverse</code>, <code>dropdims</code></li><li><code>reduce</code>, <code>mapreduce</code></li><li><code>sum</code>, <code>prod</code>, <code>maximum</code>, <code>minimum</code>,</li><li><code>mean</code>, <code>median</code>, <code>extrema</code>, <code>std</code>, <code>var</code>, <code>cor</code>, <code>cov</code></li><li><code>permutedims</code>, <code>adjoint</code>, <code>transpose</code>, <code>Transpose</code></li><li><code>mapslices</code>, <code>eachslice</code></li></ul><p><strong>Methods where dims can be used to construct <code>DimArray</code>s:</strong></p><ul><li><code>fill</code>, <code>ones</code>, <code>zeros</code>, <code>rand</code></li></ul><p><strong>Warnings</strong></p><p>Indexing with unordered or reverse order arrays has undefined behaviour. It will trash the dimension index, break <code>searchsorted</code> and nothing will make sense any more. So do it at you own risk. However, indexing with sorted vectors of Int can be useful. So it&#39;s allowed. But it will still do strange things to your interval sizes if the dimension span is <code>Irregular</code>.</p><p><strong>Alternate Packages</strong></p><p>There are a lot of similar Julia packages in this space. AxisArrays.jl, NamedDims.jl, NamedArrays.jl are registered alternative that each cover some of the functionality provided by DimensionalData.jl. DimensionalData.jl should be able to replicate most of their syntax and functionality.</p><p><a href="https://github.com/mcabbott/AxisKeys.jl">AxisKeys.jl</a> and <a href="https://github.com/Tokazama/AbstractIndices.jl">AbstractIndices.jl</a> are some other interesting developments. For more detail on why there are so many similar options and where things are headed, read this <a href="https://github.com/JuliaCollections/AxisArraysFuture/issues/1">thread</a>.</p></div></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 24 June 2021 15:23">Thursday 24 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
