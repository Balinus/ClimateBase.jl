var documenterSearchIndex = {"docs":
[{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ClimateBase is a Julia package offering basic functionality for analyzing data that are typically in the form used by climate sciences. These data are dimensional & spatiotemporal but the corresponding dimensions all need special handling. For example the most common dimensions are longitude, latitude and time.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"longitude is by definition a periodic dimension\nlatitude is a linear dimension. However because the coordinate system most often used in climate sciences is a grid of longitude × latitude (in equal degrees) the area element of space depends on latitude and this needs to be taken into account.\ntime is a linear dimension in principle, but its values are <: AbstractDateTime instead of <: Real. The human calendar (where these values come from) is periodic but each period may not correspond to the same physical time, and this also needs to be taken into account.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ClimateBase is structured to deal with these intricacies, and in addition offer several functionalities commonly used, and sought after, by climate scientists. It also serves as the base building block for ClimateTools, which offers more advanced functionalities.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"At the moment the focus of ClimateBase is not on operating on data on disk. It is designed for in-memory climate data exploration and manipulation.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is registered and you can install it with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"ClimateBase\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Make sure your installed version coincides with the one in this docs (see bottom left corner of this page).","category":"page"},{"location":"#ClimArray:-the-core-data-structure","page":"Introduction","title":"ClimArray: the core data structure","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This project treats \"climate data\" as an instance of ClimArray. At the moment ClimArray is a subtype of DimensionalArray from DimensionalData.jl. A brief introduction to DimensionalData.jl is copied here from its docs, because basic handling of a ClimArray comes from DimensionalData.jl. DimensionalData.jl allows to dimensionally-index data by their values.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"E.g. you can create an array with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using ClimateBase, Dates\r\nTime = ClimateBase.Ti # `Time` is more intuitive than `Ti`\r\nlats = -90:5:90\r\nlons = 0:10:359\r\nt = Date(2000, 3, 15):Month(1):Date(2020, 3, 15)\r\n# Here we wrap all dimension data into proper dimensions:\r\ndimensions = (Lon(lons), Lat(lats), Time(t))\r\n# where `Lon, Lat, Time` are `Dimension`s exported by ClimateBase\r\n# combining the array data with dimensions makes a `ClimArray`:\r\ndata = rand(36, 37, 241) # same size as `dimensions`\r\nA = ClimArray(data, dimensions)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can then select a specific time slice at Date(2011,5,15) and a longitude interval between 0 and 30 degrees like so:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"B = A[Lon(Between(0, 30)), Time(At(Date(2011,5,15)))]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"With ClimArray you can use convenience, physically-inspired functions that do automatic (and correct) weighting. For example the latitudinal mean of B is simply","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"C = latmean(B)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where in this averaging process each data point is weighted by the cosine of its latitude.","category":"page"},{"location":"#Making-a-ClimArray","page":"Introduction","title":"Making a ClimArray","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"You can create a ClimArray yourself, or you can load data from an .nc file with CF-conventions, see NetCDF IO.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ClimArray(::AbstractArray, ::Tuple)","category":"page"},{"location":"#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}","page":"Introduction","title":"ClimateBase.ClimArray","text":"ClimArray(A::Array, dims::Tuple; name = \"\", attrib = nothing)\n\nClimArray is a structure that contains numerical array data bundled with dimensional information, a name and an attrib field (typically a dictionary) that holds general attributes. You can think of ClimArray as a in-memory representation of a CFVariable.\n\nAt the moment, a ClimArray is using DimensionalArray from DimensionalData.jl, and all basic handling of ClimArray is offered by DimensionalData (see below).\n\nClimArray is created by passing in standard array data A and a tuple of dimensions dims. See ncread to automatically create a ClimArray from a .nc file.\n\nExample\n\nusing ClimateBase, Dates\nTime = ClimateBase.Ti # more intuitive name for time dimension\nlats = -90:5:90\nlons = 0:10:359\nt = Date(2000, 3, 15):Month(1):Date(2020, 3, 15)\n# dimensional information:\ndimensions = (Lon(lons), Lat(lats), Time(t))\ndata = rand(36, 37, 241) # numeric data\nA = ClimArray(data, dimensions)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Introduction","title":"Introduction","text":"It is strongly recommended to use the dimensions we export (because we dispatch on them and use their information):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using ClimateBase, DimensionalData # hide\r\nfor D in ClimateBase.STANDARD_DIMS\r\n    println(D, \" (full name = $(DimensionalData.name(D)))\")\r\nend","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We explicitly assume that Lon, Lat are measured in degrees and not radians or meters (extremely important for spatial averaging processes).","category":"page"},{"location":"#NetCDF-IO","page":"Introduction","title":"NetCDF IO","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ClimateBase.jl has support for file.nc ⇆ ClimArray. Usually this is done using NCDatasets.jl, but see below for a function that translates a loaded xarray (from Python) into ClimArray.","category":"page"},{"location":"#Read","page":"Introduction","title":"Read","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To load a ClimArray directly from an .nc file do:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ncread","category":"page"},{"location":"#ClimateBase.ncread","page":"Introduction","title":"ClimateBase.ncread","text":"ncread(file, var; name, kwargs...) → A\n\nLoad the variable var from the file and convert it into a ClimArray with proper dimension mapping and also containing the variable attributes as a dictionary. Dimension attributes are also given to the dimensions of A, if any exist. See keywords below for specifications for unstructured grids.\n\nfile can be a string to a .nc file. Or, it can be an NCDataset, which allows you to lazily combine different .nc data (typically split by time), e.g.\n\nusing Glob # for getting all files\nalldata = glob(\"toa_fluxes_2020_*.nc\")\nfile = NCDataset(alldata; aggdim = \"time\")\nA = ClimArray(file, \"tow_sw_all\")\n\nvar is a String denoting which variable to load. For .nc data containing groups var can also be a tuple (\"group_name\", \"var_name\") that loads a specific variable from a specific group. In this case, the attributes of both the group and the CF-variable are attributed to the created ClimArray.\n\nSee also ncdetails, nckeys and ncwrite.\n\nWe do two performance improvements while loading the data:\n\nIf there are no missing values in the data (according to CF standards), the returned array is automatically converted to a concrete type (i.e. Union{Float32, Missing} becomes Float32).\nDimensions that are ranges (i.e. sampled with constant step size) are automatically transformed to a standard Julia Range type (which makes sub-selecting faster).\n\nKeywords\n\nname optionally rename loaded array.\ngrid = nothing optionally specify whether the underlying grid is grid = LonLatGrid() or grid = UnstructuredGrid(), see Types of spatial coordinates. If nothing, we try to deduce automatically based on the names of dimensions and other keys of the NCDataset.\nlon, lat. These two keywords are useful in unstructured grid data where the grid information is provided in a separate .nc file. What we need is the user to provide vectors of the central longitude and central latitude of each grid point. This is done e.g. by\nds = NCDataset(\"path/to/grid.nc\");\nlon = Array(ds[\"clon\"]);\nlat = Array(ds[\"clat\"]);\nIf lon, lat are given, grid is automatically assumed UnstructuredGrid().\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"Notice that (at the moment) we use a pre-defined mapping of common names to proper dimensions - please feel free to extend the following via a Pull Request:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using ClimateBase # hide\r\nClimateBase.COMMONNAMES","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Also, the following convenience functions are provided for examining the content of on-disk .nc files without loading all data on memory.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"nckeys\r\nncdetails\r\nglobalattr","category":"page"},{"location":"#ClimateBase.nckeys","page":"Introduction","title":"ClimateBase.nckeys","text":"nckeys(file::String)\n\nReturn all keys of the .nc file in file.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.ncdetails","page":"Introduction","title":"ClimateBase.ncdetails","text":"ncdetails(file::String, io = stdout)\n\nPrint details about the .nc file in file on io.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.globalattr","page":"Introduction","title":"ClimateBase.globalattr","text":"globalattr(file::String) → Dict\n\nReturn the global attributes of the .nc file.\n\n\n\n\n\n","category":"function"},{"location":"#Write","page":"Introduction","title":"Write","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"You can also write a bunch of ClimArrays directly into an .nc file with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ncwrite","category":"page"},{"location":"#ClimateBase.ncwrite","page":"Introduction","title":"ClimateBase.ncwrite","text":"ncwrite(file::String, Xs; globalattr = Dict())\n\nWrite the given ClimArray instances (any iterable of ClimArrays or a single ClimArray) to a .nc file following CF standard conventions using NCDatasets.jl. Optionally specify global attributes for the .nc file.\n\nThe metadata of the arrays in Xs, as well as their dimensions, are properly written in the .nc file and any necessary type convertions happen automatically.\n\nWARNING: We assume that any dimensions shared between the Xs are identical.\n\nSee also ncread.\n\n\n\n\n\n","category":"function"},{"location":"#xarray","page":"Introduction","title":"xarray","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"You can use the following functions (which are not defined and exported in ClimateBase to avoid dependency on PyCall.jl) to load data using Python's xarray.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using ClimateBase, Dates\r\n# This needs to numpy, xarray and dask installed from Conda\r\nusing PyCall\r\nxr = pyimport(\"xarray\")\r\nnp = pyimport(\"numpy\")\r\n\r\nfunction climarray_from_xarray(xa, fieldname, name = fieldname)\r\n    w = getproperty(xa, Symbol(fieldname))\r\n    raw_data = Array(w.values)\r\n    dnames = collect(w.dims) # dimensions in string name\r\n    dim_values, dim_attrs = extract_dimension_values_xarray(xa, dnames)\r\n    @assert collect(size(raw_data)) == length.(dim_values)\r\n    actual_dims = create_dims_xarray(dnames, dim_values, dim_attrs)\r\n    ca = ClimArray(raw_data, actual_dims, name; attrib = w.attrs)\r\nend\r\n\r\nfunction extract_dimension_values_xarray(xa, dnames = collect(xa.dims))\r\n    dim_values = []\r\n    dim_attrs = Vector{Any}(fill(nothing, length(dnames)))\r\n    for (i, d) in enumerate(dnames)\r\n        dim_attrs[i] = getproperty(xa, d).attrs\r\n        x = getproperty(xa, d).values\r\n        if d ≠ \"time\"\r\n            push!(dim_values, x)\r\n        else\r\n            dates = [np.datetime_as_string(y)[1:19] for y in x]\r\n            dates = DateTime.(dates)\r\n            push!(dim_values, dates)\r\n        end\r\n    end\r\n    return dim_values, dim_attrs\r\nend\r\n\r\nfunction create_dims_xarray(dnames, dim_values, dim_attrs)\r\n    true_dims = ClimateBase.to_proper_dimensions(dnames)\r\n    optimal_values = ClimateBase.vector2range.(dim_values)\r\n    out = []\r\n    for i in 1:length(true_dims)\r\n        push!(out, true_dims[i](optimal_values[i]; metadata = dim_attrs[i]))\r\n    end\r\n    return (out...,)\r\nend\r\n\r\n# Load some data\r\nxa = xr.open_mfdataset(ERA5_files_path)\r\nX = climarray_from_xarray(xa, \"w\", \"optional name\")","category":"page"},{"location":"#Temporal","page":"Introduction","title":"Temporal","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Functions related with the Time dimension.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"timemean\r\ntimeagg\r\nmonthlyagg\r\nyearlyagg\r\nseasonalyagg\r\ntemporalrange\r\nmaxyearspan\r\ntemporal_sampling\r\nrealtime_days\r\nrealtime_milliseconds\r\nseasonality","category":"page"},{"location":"#ClimateBase.timemean","page":"Introduction","title":"ClimateBase.timemean","text":"timemean(A::ClimArray [, w]) = timeagg(mean, A, w)\n\nTemporal average of A, see timeagg.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.timeagg","page":"Introduction","title":"ClimateBase.timeagg","text":"timeagg(f, A::ClimArray, W = nothing)\n\nPerform a proper temporal aggregation of the function f (e.g. mean, std) on A where:\n\nOnly full year spans of A are included, see maxyearspan (because most processes are affected by yearly cycle, and averaging over an uneven number of cycles typically results in artifacts)\nEach month in A is weighted with its length in days (for monthly sampled data)\n\nIf you don't want these features, just do dropagg(f, A, Time, W). This is also done in the case where the time sampling is unknown.\n\nW are possible statistical weights that are used in conjuction to the temporal weighting, to weight each time point differently. If they are not a vector (a weight for each time point), then they have to be a dimensional array of same dimensional layout as A (a weight for each data point).\n\nSee also monthlyagg, yearlyagg, seasonalyagg.\n\ntimeagg(f, t::Vector, x::Vector, w = nothing)\n\nSame as above, but for arbitrary vector x accompanied by time vector t.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.monthlyagg","page":"Introduction","title":"ClimateBase.monthlyagg","text":"monthlyagg(A::ClimArray, f = mean; mday = 15) -> B\n\nCreate a new array where the temporal information has been aggregated into months using the function f. The dates of the new array always have day number of mday.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.yearlyagg","page":"Introduction","title":"ClimateBase.yearlyagg","text":"yearlyagg(A::ClimArray, f = mean) -> B\n\nCreate a new array where the temporal information has been aggregated into years using the function f. By convention, the dates of the new array always have month and day number of 1.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.seasonalyagg","page":"Introduction","title":"ClimateBase.seasonalyagg","text":"seasonalyagg(A::ClimArray, f = mean) -> B\n\nCreate a new array where the temporal information has been aggregated into seasons using the function f. By convention, seasons are represented as Dates spaced 3-months apart, where only the months December, March, June and September are used to specify the date, with day 1.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.temporalrange","page":"Introduction","title":"ClimateBase.temporalrange","text":"temporalrange(A::ClimArray, f = Dates.month) → r\ntemporalrange(t::AbstractVector{<:TimeType}}, f = Dates.month) → r\n\nReturn a vector of ranges so that each range of indices are values of t that belong in either the same month, year, day, or season, depending on f. f can take the values: Dates.year, Dates.month, Dates.day or season (all are functions).\n\nUsed in e.g. monthlyagg, yearlyagg or seasonalyagg.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.maxyearspan","page":"Introduction","title":"ClimateBase.maxyearspan","text":"maxyearspan(A::ClimArray) = maxyearspan(dims(A, Time))\nmaxyearspan(t::Vector{<:DateTime}) → i\n\nFind the maximum index i of t so that t[1:i] covers exact(*) multiples of years.\n\n(*) For monthly spaced data i is a multiple of 12 while for daily data we find the largest possible multiple of DAYS_IN_ORBIT.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.temporal_sampling","page":"Introduction","title":"ClimateBase.temporal_sampling","text":"temporal_sampling(x) → symbol\n\nReturn the temporal sampling type of x, which is either an array of Dates or a dimensional array (with Time dimension).\n\nPossible return values are:\n\n:hourly, where the temporal difference between successive entries is exactly 1 hour.\n:daily, where the temporal difference between successive entries is exactly 1 day.\n:monthly, where all dates have the same day, but different month.\n:yearly, where all dates have the same month and day, but different year.\n:other, which means that x doesn't fall to any of the above categories.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.realtime_days","page":"Introduction","title":"ClimateBase.realtime_days","text":"realtime_days(t::AbstractVector{<:TimeType}, T = Float32)\n\nConvert the given sequential date time vector t in a vector in a format of \"real time\", where time is represented by real numbers, increasing cumulatively, as is the case when representing a timeseries x(t). As only differences matter in this form, the returned vector always starts from 0. The measurement unit of time here is days.\n\nFor temporal sampling less than daily return realtime_milliseconds(t) ./ (24*60*60*1000).\n\nExample:\n\njulia> t = Date(2004):Month(1):Date(2004, 6)\nDate(\"2004-01-01\"):Month(1):Date(\"2004-06-01\")\n\njulia> realtime_days(t)\n6-element Vector{Float32}:\n   0.0\n  29.0\n  60.0\n  90.0\n 121.0\n 151.0\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.realtime_milliseconds","page":"Introduction","title":"ClimateBase.realtime_milliseconds","text":"realtime_milliseconds(t::AbstractArray{<:TimeType}, T = Float64)\n\nSimilar with realtime_days, but now the measurement unit is millisecond. For extra accuracy, direct differences in t are used.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.seasonality","page":"Introduction","title":"ClimateBase.seasonality","text":"seasonality(t, x; y0 = year(t[1])) → dates, vals\n\nCalculate the \"seasonality\" of a vector x defined with respect to a datetime vector t and return dates, vals. dates are all unique dates present in t disregarding the year (so only the month and day are compared). The dates have as year entry y0. vals is a vector of vectors, where vals[i] are all the values of x that have day and month same as dates[i]. The elements of vals are sorted as encountered in x.\n\nTypically one is interested in mean.(vals), which actually is the seasonality, and std.(vals) which is the interannual variability at each date.\n\nseasonality(A::ClimArray) → dates, vals\n\nIf given a ClimArray, then the array must have only one dimension (time).\n\n\n\n\n\n","category":"function"},{"location":"#Spatial","page":"Introduction","title":"Spatial","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"All functions in this section work for both types of space, see Types of spatial coordinates.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"zonalmean\r\nlatmean\r\nspacemean\r\nspaceagg\r\nhemispheric_means\r\nhemispheric_functions\r\ntropics_extratropics\r\nlonlatfirst\r\nlongitude_circshift","category":"page"},{"location":"#ClimateBase.zonalmean","page":"Introduction","title":"ClimateBase.zonalmean","text":"zonalmean(A::ClimArray [, W])\n\nReturn the zonal mean of A. Works for both LonLatGrid as well as UnstructuredGrid. Optionally provide statistical weights W. These can be the same size as A or only having the same latitude structure as A.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.latmean","page":"Introduction","title":"ClimateBase.latmean","text":"latmean(A::ClimArray)\n\nReturn the latitude-mean A (mean across dimension Lat). This function properly weights by the cosine of the latitude.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.spacemean","page":"Introduction","title":"ClimateBase.spacemean","text":"spacemean(A::ClimArray [, W]) = spaceagg(mean, A, W)\n\nAverage given A over its spatial coordinates. Optionally provide statistical weights in W.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.spaceagg","page":"Introduction","title":"ClimateBase.spaceagg","text":"spaceagg(f, A::ClimArray, W = nothing)\n\nAggregate A using function f (e.g. mean, std) over all available space (i.e. longitude and latitude) of A, weighting every part of A by its spatial area.\n\nW can be extra weights, to weight each spatial point with. W can either be a ClimArray with same spatial information as A, or having exactly same dimensions as A.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.hemispheric_means","page":"Introduction","title":"ClimateBase.hemispheric_means","text":"hemispheric_means(A) → nh, sh\n\nReturn the (proper) averages of A over the northern and southern hemispheres. Notice that this function explicitly does both zonal as well as meridional averaging. Use hemispheric_functions to just split A into two hemispheres.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.hemispheric_functions","page":"Introduction","title":"ClimateBase.hemispheric_functions","text":"hemispheric_functions(A::ClimArray) → north, south\n\nReturn two arrays north, south, by splitting A to its northern and southern hemispheres, appropriately translating the latitudes of south so that both arrays have the same latitudinal dimension (and thus can be compared and do opperations between them).\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.tropics_extratropics","page":"Introduction","title":"ClimateBase.tropics_extratropics","text":"tropics_extratropics(A::ClimArray; lower_lat=30, higher_lat=90) → tropics, extratropics\n\nSeparate the given array into two arrays: one having latitudes ℓ ∈ [-lowerlat, +lowerlat], and one having [-higherlat:-lowerlat, lowerlat:higherlat]. lowerlat defaults to 30 degrees and higherlat defaults to 90.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.lonlatfirst","page":"Introduction","title":"ClimateBase.lonlatfirst","text":"lonlatfirst(A::ClimArray, args...) → B\n\nPermute the dimensions of A to make a new array B that has first dimension longitude, second dimension latitude, with the remaining dimensions of A following (useful for most plotting functions). Optional extra dimensions can be given as args..., specifying a specific order for the remaining dimensions.\n\nExample:\n\nB = lonlatfirst(A)\nC = lonlatfirst(A, Time)\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.longitude_circshift","page":"Introduction","title":"ClimateBase.longitude_circshift","text":"longitude_circshift(X::ClimArray, l = size(X, Lon)÷2, wrap = false)\n\nPerform the same action as Base.circshift, but only for the longitudinal dimension of X with shift l. If wrap = true the longitudes are wrapped to (-180, 180) degrees.\n\n\n\n\n\n","category":"function"},{"location":"#Types-of-spatial-coordinates","page":"Introduction","title":"Types of spatial coordinates","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"At the moment the following type of spatial coordinates are supported:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"LonLatGrid\r\nUnstructuredGrid","category":"page"},{"location":"#ClimateBase.LonLatGrid","page":"Introduction","title":"ClimateBase.LonLatGrid","text":"Space coordinates are represented by two orthogonal dimensions Lon, Lat, one being longitude and the other being latitude.\n\n\n\n\n\n","category":"type"},{"location":"#ClimateBase.UnstructuredGrid","page":"Introduction","title":"ClimateBase.UnstructuredGrid","text":"Space coordinates are represented by a single dimension Coord, whose elements are coordinate locations, i.e. 2-element SVector(longitude, latitude). Each coordinate represents an equal area polygon corresponding to the point in space. The actual limits of each polygon are not included in the dimension for performance reasons.\n\nThis dimension allows indexing according to the underlying Lon, Lat representation, e.g. you can do\n\nA # some `ClimArray` with unstructured grid type.\nA[Coord(Lon(Between(0, 30)), Lat(Between(-30, 30)))]\n\nTo use functions such as zonalmean or hemispheric_means with this grid, you must first sort the ClimArray so that the latitudes of its coordinates are sorted in ascending order. I.e.\n\nA # some `ClimArray` with unstructured grid type.\ncoords = dims(A, Coord).val\nsi = sortperm(coords, by = reverse)\nA = A[Coord(si)]\n\nThis is done automatically by ncread.\n\nwarn: Warn\nUnstructuredGrid functionality is currently in an experimental phase! Notice that non-equal area unstructured grids are not supported yet.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Introduction","title":"Introduction","text":"ClimateBase.jl works with either type of spatial coordinate system. Therefore, physically inspired averaging functions, like spacemean or zonalmean, work for both types of spatial coordinates. In addition, the function spatialidxs returns an iterator over the spatial coordinates of the data, and works for both types (grid or equal-area):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"spatialidxs","category":"page"},{"location":"#ClimateBase.spatialidxs","page":"Introduction","title":"ClimateBase.spatialidxs","text":"spatialidxs(A::ClimArray) → idxs\n\nReturn an iterable that can be used to access all spatial points of A with the syntax\n\nidxs = spatialidxs(A)\nfor i in idxs\n    slice_at_give_space_point = A[i...]\nend\n\nWorks for all types of space (... is necessary because i is a Tuple).\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"ncread tries to automatically deduce the correct space type and create the appropriate dimension.","category":"page"},{"location":"#General-aggregation","page":"Introduction","title":"General aggregation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The physical averages of the previous section are done by taking advantage of a general aggregation syntax, which works with any aggregating function like mean, sum, std, etc.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"dropagg\r\ncollapse","category":"page"},{"location":"#ClimateBase.dropagg","page":"Introduction","title":"ClimateBase.dropagg","text":"dropagg(f, A, d [, W])\n\nApply statistics/aggregating function f (e.g. sum or mean) on array A across dimension(s) d and drop the corresponding dimension(s) from the result (Julia inherently keeps singleton dimensions).\n\nIf A is one dimensional, dropagg will return the single number of applying f(A).\n\nOptionally you can provide statistical weights in the form of an array W. W must have same size as A. An exception is when d is only a single dimension, e.g. d = Lat; then W is also allowed to be a single vector with length the same as dims(A, d).\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.collapse","page":"Introduction","title":"ClimateBase.collapse","text":"collapse(f, A, dim)\n\nReduce A towards dimension dim using the collapsing function f (e.g. mean). This means that f is applied across all other dimensions of A, each of which are subsequently dropped, leaving only the collapsed result of A vs. the remaining dimension.\n\n\n\n\n\n","category":"function"},{"location":"#Missing-data","page":"Introduction","title":"Missing data","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"When loading an array with ncread, the values of the return array may contain missing values if the actual data contain missing values according to the CF-standards. In other packages or other programming languages these missing values are handled \"internally\" and e.g. in statistical operations like mean, the statistics explicitly skip over missing values. For example this is a typical workflow of creating an array, assigning missing to all values of an array over land, and then taking the mean of the array, which would be the \"mean over ocean\".","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ClimateBase.jl does not follow this approach for two reasons: 1) it does not comply with Julia's missing propagation logic, 2) using proper statistical weights gives more power to the user. As you have already seen in the documentation strings of e.g. timeagg, spaceagg or dropagg, you can provide explicit statistical weights of various forms. This gives you more power, because in the case of missing your statistical weights can only be 0 (missing value) or 1 (non-missing value). As an example, \"pixel\" of your spatial grid will have ambiguous values if it is not 100% covered by ocean, and to do a proper average over ocean you should instead provide weights W whose value is quite simply the ocean fraction of each pixel.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"But what if you already have an array with missing values and you want to do what was described in the beginning, e.g. average by skipping the missings? Do not worry, we have you covered! Use the function missing_weights! See also sinusoidal_continuation if the missing values are only in a subset of your temporal coverage.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"missing_weights\r\nmissing_val","category":"page"},{"location":"#ClimateBase.missing_weights","page":"Introduction","title":"ClimateBase.missing_weights","text":"missing_weights(A::ClimArray, val = missing_val(A)) → B, W\n\nGenerate a new array B with values like A, but with A's missing values replaced with val. Also generate an array of weights, which has the value 0 when A had missing, and the value 1 otherwise.\n\nThe output of this function should be used in conjunction with any of ClimateBase.jl aggregating functions like spacemean, timemean, ..., when your data have missing values which you want to completely skip during the aggregation process.\n\nThis function returns A, nothing if A has no missing values.\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.missing_val","page":"Introduction","title":"ClimateBase.missing_val","text":"missing_val(A)\n\nReturn the value that represents \"missing\" data in A, according to A's metadata. If A does not have the _FillValue metadata, return 0 instead.\n\n\n\n\n\n","category":"function"},{"location":"#Timeseries-Analysis","page":"Introduction","title":"Timeseries Analysis","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"sinusoidal_continuation\r\nseasonal_decomposition","category":"page"},{"location":"#ClimateBase.sinusoidal_continuation","page":"Introduction","title":"ClimateBase.sinusoidal_continuation","text":"sinusoidal_continuation(T::ClimArray, fs = [1, 2]; Tmin = -Inf, Tmax = Inf)\n\nFill-in the missing values of spatiotemporal field T, by fitting sinusoidals to the non-missing values, and then using the fitted sinusoidals for the missing values.\n\nFrequencies are given per year (frequency 2 means 1/2 of a year).\n\nTmin, Tmax limits are used to clamp the result into this range (no clamping in the default case).\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.seasonal_decomposition","page":"Introduction","title":"ClimateBase.seasonal_decomposition","text":"seasonal_decomposition(A::ClimArray, fs = [1, 2]) → seasonal, residual\n\nDecompose A into a seasonal and residual components, where the seasonal contains the periodic parts of A, with frequencies given in fs, and residual contains what's left.\n\nfs is measured in 1/year. This function works even for non-equispaced time axis (e.g. monthly averages) and uses LPVSpectral.jl and SignalDecomposition.jl.\n\n\n\n\n\n","category":"function"},{"location":"#Climate-quantities","page":"Introduction","title":"Climate quantities","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Functions that calculate climate-related quantities.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"insolation\r\nsurface_atmosphere_contributions\r\ntotal_toa_albedo","category":"page"},{"location":"#ClimateBase.insolation","page":"Introduction","title":"ClimateBase.insolation","text":"insolation(t, ϕ; kwargs...)\n\nCalculate daily averaged insolation in W/m² at given time and latitude t, φ. φ is given in degrees, and t in days (real number or date).\n\nKeywords:\n\nYa = DAYS_IN_ORBIT # = 365.26 # days\nt_VE = 76.0 # days of vernal equinox\nS_0 = 1362.0 # W/m^2\nγ=23.44\nϖ=282.95\ne=0.017 # eccentricity\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.surface_atmosphere_contributions","page":"Introduction","title":"ClimateBase.surface_atmosphere_contributions","text":"surface_atmosphere_contributions(I, F_toa_⬆, F_s_⬆, F_s_⬇) → α_ATM, α_SFC\n\nCalculate the atmospheric and surface contributions of the planetary albedo, so that the TOA albedo is α = α_ATM + α_SFC, using the simple 1-layer radiative transfer model by Donohoe & Battisti (2011) or G. Stephens (2015). Stephens' formulas are incorrect and I have corrected them!\n\n\n\n\n\n","category":"function"},{"location":"#ClimateBase.total_toa_albedo","page":"Introduction","title":"ClimateBase.total_toa_albedo","text":"total_toa_albedo(a, s, t) = a + s*t^2/(1-a*s)\n\nCombine given atmosphere albedo a, surface albedo s and atmosphere transmittance t into a total top-of-the-atmosphere albedo α according to the model of Donohoe & Battisti (2011).\n\n\n\n\n\n","category":"function"},{"location":"#Plotting","page":"Introduction","title":"Plotting","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently ClimateBase.jl does not have integrated plotting support. In the near future it will have this based on the upcoming GeoMakie.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For now, you can use PyCall.jl, matplotlib, and the Python library cartopy. In the file ClimateBase/plotting/python.jl we provide two functions that plot maps of ClimArray in arbitrary projections: earthsurface for LonLatGrid and earthscatter for UnstructuredGrid. You can incorporate these in your source code as a temporary solution.","category":"page"},{"location":"#Ensemble-types","page":"Introduction","title":"Ensemble types","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A dedicated type representing ensembles has no reason to exist in ClimateBase.jl. As the package takes advantage of standard Julia datastructures and syntax, those can be used to represent \"ensembles\". For example to do an \"ensemble global mean\" you can just do:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"E = [ClimArray(\"ensemble_$i.nc\", \"x\") for i in 1:10]\r\nglobal_mean = mean(spacemean(X) for X in E)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where you see that the \"ensemble\" was represented just as a Vector{ClimArray}.","category":"page"},{"location":"#Crash-course-to-DimensionalData.jl","page":"Introduction","title":"Crash-course to DimensionalData.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DimensionalData","category":"page"},{"location":"#DimensionalData","page":"Introduction","title":"DimensionalData","text":"DimensionalData\n\n(Image: ) (Image: ) (Image: CI) (Image: Codecov) (Image: Aqua.jl Quality Assurance)\n\nDimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions, and optionally a lookup index. It's a pluggable,  generalised version of AxisArrays.jl  with a cleaner syntax, and additional functionality found in NamedDims.jl. It has  similar goals to pythons xarray, and is primarily written for use with spatial data in GeoData.jl.\n\nBroadcasting and most Base methods maintain and sync dimension context.\n\nDimensionalData.jl also implements:\n\ncomprehensive plot recipes for Plots.jl.\na Tables.jl interface with DimTable\nmulti-layered DimStacks that can be indexed together,    and have base methods applied to all layers.\nthe Adapt.jl interface for use on GPUs, even as GPU kernel arguments.\ntraits for handling a wide range of spatial data types accurately.\n\nDimensions\n\nDimensions are wrapper types. They hold the lookup index, details about the  grid, and other metadata. They are also used to index into the array.  X, Y, Z and Ti are the exported defaults. A generalised Dim type is available  to use arbitrary symbols to name dimensions. Custom dimension types can also be defined  using the @dim macro.\n\nDimensions can be used to construct arrays in rand, ones, zeros and fill with  either a range for a lookup index or a number for the dimension length:\n\njulia> using DimensionalData\n\njulia> A = rand(X(1:40), Y(50))\n40×50 DimArray{Float64,2} with dimensions:\n  X: 1:40 (Sampled - Ordered Regular Points)\n  Y\n 0.929006   0.116946  0.750017  …  0.172604  0.678835   0.495294\n 0.0550038  0.100739  0.427026     0.778067  0.309657   0.831754\n ⋮                              ⋱\n 0.647768   0.965682  0.049315     0.220338  0.0326206  0.36705\n 0.851769   0.164914  0.555637     0.771508  0.964596   0.30265\n\nWe can also use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:\n\njulia> A[Y(1), X(1:10)]\n10-element DimArray{Float64,1} with dimensions:\n  X: 1:10 (Sampled - Ordered Regular Points)\nand reference dimensions: Y(1) \n 0.929006\n 0.0550038\n 0.641773\n ⋮\n 0.846251\n 0.506362\n 0.0492866\n\nAnd this has no runtime cost:\n\njulia> A = ones(X(3), Y(3))\n3×3 DimArray{Float64,2} with dimensions: X, Y\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> @btime $A[X(1), Y(2)]\n  1.077 ns (0 allocations: 0 bytes)\n1.0\n\njulia> @btime parent($A)[1, 2]\n  1.078 ns (0 allocations: 0 bytes)\n1.0\n\nDims can be used for indexing and views without knowing dimension order:\n\njulia> A = rand(X(40), Y(50))\n40×50 DimArray{Float64,2} with dimensions: X, Y\n 0.377696  0.105445  0.543156  …  0.844973  0.163758  0.849367\n ⋮                             ⋱\n 0.431454  0.108927  0.137541     0.531587  0.592512  0.598927\n\njulia> A[Y=3]\n40-element DimArray{Float64,1} with dimensions: X\nand reference dimensions: Y(3)\n 0.543156\n ⋮\n 0.137541\n\njulia> view(A, Y(), X(1:5))\n5×50 DimArray{Float64,2} with dimensions: X, Y\n 0.377696  0.105445  0.543156  …  0.844973  0.163758  0.849367\n ⋮                             ⋱\n 0.875279  0.133032  0.925045     0.156768  0.736917  0.444683\n\nAnd for specifying dimension number in all Base and Statistics  functions that have a dims argument:\n\njulia> using Statistics\n\njulia> A = rand(X(3), Y(4), Ti(5));\n\njulia> mean(A; dims=Ti)\n3×4×1 DimArray{Float64,3} with dimensions: X, Y, Ti (Time)\n[:, :, 1]\n 0.168058  0.52353   0.563065  0.347025\n 0.472786  0.395884  0.307846  0.518926\n 0.365028  0.381367  0.423553  0.369339\n\nYou can also use symbols to create Dim{X} dimensions, although we can't use the rand method directly with Symbols, and insteadd use the regular DimArray constructor:\n\njulia> A = DimArray(rand(10, 20, 30), (:a, :b, :c));\n\njulia> A[a=2:5, c=9]\n\n4×20 DimArray{Float64,2} with dimensions: Dim{:a}, Dim{:b}\nand reference dimensions: Dim{:c}(9)\n 0.134354  0.581673  0.422615  …  0.410222   0.687915  0.753441\n 0.573664  0.547341  0.835962     0.0353398  0.794341  0.490831\n 0.166643  0.133217  0.879084     0.695685   0.956644  0.698638\n 0.325034  0.147461  0.149673     0.560843   0.889962  0.75733\n\nSelectors\n\nSelectors find indices in the lookup index for each dimension: \n\nAt(x): get the index exactly matching the passed in value(s)\nNear(x): get the closest index to the passed in value(s)\nWhere(f::Function): filter the array axis by a function of the    dimension index values.\nBetween(a, b): get all indices between two values, excluding the high value.\nContains(x): get indices where the value x falls within the interval, exluding    the upper value. Only used for Sampled Intervals, for Points, use At.\n\n(Between and Contains exlude the upper boundary so that adjacent selections never contain the same index)\n\nSelectors can be used in getindex, setindex! and view to select indices matching the passed in value(s)\n\nWe can use selectors inside dim wrappers:\n\njulia> using Dates\n\njulia> timespan = DateTime(2001,1):Month(1):DateTime(2001,12)\nDateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-12-01T00:00:00\")\n\njulia> A = DimArray(rand(12,10), (Ti(timespan), X(10:10:100)))\n12×10 DimArray{Float64,2} with dimensions:\n  Ti (Time): DateTime(\"2001-01-01T00:00:00\"):Month(1):DateTime(\"2001-12-01T00:00:00\") (Sampled - Ordered Regular Points)\n  X: 10:10:100 (Sampled - Ordered Regular Points)\n 0.14106   0.476176  0.311356  0.454908  …  0.464364  0.973193  0.535004\n ⋮                                       ⋱\n 0.522759  0.390414  0.797637  0.686718     0.901123  0.704603  0.0740788\n\njulia> @btime A[X(Near(35)), Ti(At(DateTime(2001,5)))]\n0.3133109280208961\n\nWithout dim wrappers selectors must be in the right order:\n\nusing Unitful\n\njulia> A = rand(X((1:10:100)u\"m\"), Ti((1:5:100)u\"s\"));\n\njulia> A[Between(10.5u\"m\", 50.5u\"m\"), Near(23u\"s\")]\n4-element DimArray{Float64,1} with dimensions:\n  X: (11:10:41) m (Sampled - Ordered Regular Points)\nand reference dimensions:\n  Ti(21 s) (Time): 21 s (Sampled - Ordered Regular Points)\n 0.584028\n ⋮\n 0.716715\n\nFor values other than Int/AbstractArray/Colon (which are set aside for regular indexing) the At selector is assumed, and can be dropped completely:\n\njulia> A = rand(X([:a, :b, :c]), Y([25.6, 25.7, 25.8]));\n\njulia> A[:b, 25.8]\n0.61839141062599\n\nCompile-time selectors\n\nUsing all Val indexes (only recommended for small arrays) you can index with named dimensions At arbitrary values with no runtime cost:\n\njulia> A = rand(X(Val((:a, :b, :c))), Y(Val((5.0, 6.0, 7.0))))\n3×3 DimArray{Float64,2} with dimensions:\n  X: Val{(:a, :b, :c)}() (Categorical - Unordered)\n  Y: Val{(5.0, 6.0, 7.0)}() (Categorical - Unordered)\n 0.5808   0.835037  0.528461\n 0.8924   0.431394  0.506915\n 0.66386  0.955305  0.774132\n\njulia> @btime $A[:c, 6.0]\n  2.777 ns (0 allocations: 0 bytes)\n0.9553052910459472\n\njulia> @btime $A[Val(:c), Val(6.0)]\n  1.288 ns (0 allocations: 0 bytes)\n0.9553052910459472\n\nMethods where dims can be used containing indices or Selectors\n\ngetindex, setindex! view\n\nMethods where dims, dim types, or Symbols can be used to indicate the array dimension:\n\nsize, axes, firstindex, lastindex\ncat, reverse, dropdims\nreduce, mapreduce\nsum, prod, maximum, minimum,\nmean, median, extrema, std, var, cor, cov\npermutedims, adjoint, transpose, Transpose\nmapslices, eachslice\n\nMethods where dims can be used to construct DimArrays:\n\nfill, ones, zeros, rand\n\nWarnings\n\nIndexing with unordered or reverse order arrays has undefined behaviour. It will trash the dimension index, break searchsorted and nothing will make sense any more. So do it at you own risk. However, indexing with sorted vectors of Int can be useful. So it's allowed. But it will still do strange things to your interval sizes if the dimension span is Irregular.\n\nAlternate Packages\n\nThere are a lot of similar Julia packages in this space. AxisArrays.jl, NamedDims.jl, NamedArrays.jl are registered alternative that each cover some of the functionality provided by DimensionalData.jl. DimensionalData.jl should be able to replicate most of their syntax and functionality.\n\nAxisKeys.jl and AbstractIndices.jl are some other interesting developments. For more detail on why there are so many similar options and where things are headed, read this thread.\n\n\n\n\n\n","category":"module"}]
}
