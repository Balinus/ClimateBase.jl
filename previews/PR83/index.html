<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · ClimateBase</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Quicksand|Montserrat|Source+Code+Pro|Lora&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ClimateBase</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#ClimArray:-the-core-data-structure"><span><code>ClimArray</code>: the core data structure</span></a></li><li><a class="tocitem" href="#NetCDF-IO"><span>NetCDF IO</span></a></li><li><a class="tocitem" href="#Ensemble-types"><span>Ensemble types</span></a></li><li><a class="tocitem" href="#Crash-course-to-DimensionalData.jl"><span>Crash-course to DimensionalData.jl</span></a></li></ul></li><li><a class="tocitem" href="statistics/">Statistics</a></li><li><a class="tocitem" href="plotting/">Plotting</a></li><li><a class="tocitem" href="advanced/">Advanced functionality</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p><code>ClimateBase</code> is a Julia package offering basic functionality for analyzing data that are typically in the form used by climate sciences. These data are dimensional &amp; spatiotemporal but the corresponding dimensions all need special handling. For example the most common dimensions are longitude, latitude and time.</p><ul><li>longitude is by definition a periodic dimension</li><li>latitude is a linear dimension. However because the coordinate system most often used in climate sciences is a grid of longitude × latitude (in equal degrees) the area element of space depends on latitude and this needs to be taken into account.</li><li>time is a linear dimension <em>in principle</em>, but its values are <code>&lt;: AbstractDateTime</code> instead of <code>&lt;: Real</code>. The human calendar (where these values come from) is periodic but each period may not correspond to the same physical time, and this also needs to be taken into account.</li></ul><p><code>ClimateBase</code> is structured to deal with these intricacies, and in addition offer several functionalities commonly used, and sought after, by climate scientists. It also serves as the base building block for <code>ClimateTools</code>, which offers more advanced functionalities.</p><p>At the moment the focus of <code>ClimateBase</code> is <strong>not</strong> on operating on data <em>on disk</em>. It is designed for in-memory climate data exploration and manipulation.</p><h3 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h3><p>This package is registered and you can install it with</p><pre><code class="language-julia hljs">using Pkg; Pkg.add(&quot;ClimateBase&quot;)</code></pre><p>Make sure your installed version coincides with the one in this docs (see bottom left corner of this page).</p><h2 id="ClimArray:-the-core-data-structure"><a class="docs-heading-anchor" href="#ClimArray:-the-core-data-structure"><code>ClimArray</code>: the core data structure</a><a id="ClimArray:-the-core-data-structure-1"></a><a class="docs-heading-anchor-permalink" href="#ClimArray:-the-core-data-structure" title="Permalink"></a></h2><p>This project treats &quot;climate data&quot; as an instance of <a href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimArray</code></a>. At the moment <code>ClimArray</code> is a subtype of <code>DimensionalArray</code> from DimensionalData.jl. A brief introduction to DimensionalData.jl is copied here from its docs, because basic handling of a <code>ClimArray</code> comes from DimensionalData.jl. DimensionalData.jl allows to dimensionally-index data by their values.</p><p>E.g. you can create an array with</p><pre><code class="language-julia hljs">using ClimateBase, Dates
Time = ClimateBase.Ti # `Time` is more intuitive than `Ti`
lats = -90:5:90
lons = 0:10:359
t = Date(2000, 3, 15):Month(1):Date(2020, 3, 15)
# Here we wrap all dimension data into proper dimensions:
dimensions = (Lon(lons), Lat(lats), Time(t))
# where `Lon, Lat, Time` are `Dimension`s exported by ClimateBase
# combining the array data with dimensions makes a `ClimArray`:
data = rand(36, 37, 241) # same size as `dimensions`
A = ClimArray(data, dimensions)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ClimArray with dimensions:
  Lon (Longitude): 0:10:350 Sampled: Ordered Regular Points,
  Lat (Latitude): -90:5:90 Sampled: Ordered Regular Points,
  Ti (Time): Dates.Date(&quot;2000-03-15&quot;):Dates.Month(1):Dates.Date(&quot;2020-03-15&quot;)
    Sampled: Ordered Regular Points
and data: 36×37×241 Array{Float64, 3}
[:, :, 1]
 0.0894901  0.0770547  0.683748  0.808504  …  0.0333786  0.969498    0.413828
 0.126515   0.282562   0.436303  0.868911     0.589588   0.00428567  0.465555
 0.265757   0.263926   0.256885  0.814506     0.48444    0.958676    0.96684
 0.305087   0.846268   0.715461  0.688158     0.939087   0.32574     0.733107
 ⋮                                         ⋱             ⋮           
 0.19626    0.541277   0.892856  0.417655     0.239361   0.739704    0.996281
 0.591289   0.314093   0.523617  0.894026     0.852609   0.394062    0.775843
 0.791227   0.0345745  0.90513   0.851255     0.51108    0.0163885   0.124302
 0.508024   0.402183   0.46595   0.441815  …  0.285538   0.488366    0.209642
[and 240 more slices...]</code></pre><p>You can then select a specific time slice at <code>Date(2011,5,15)</code> and a longitude interval between 0 and 30 degrees like so:</p><pre><code class="language-julia hljs">B = A[Lon(Between(0, 30)), Time(At(Date(2011,5,15)))]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ClimArray with dimensions:
  Lon (Longitude): 0:10:30 Sampled: Ordered Regular Points,
  Lat (Latitude): -90:5:90 Sampled: Ordered Regular Points
and data: 4×37 Matrix{Float64}
 0.898863  0.219553  0.782616  0.950707  …  0.7392    0.53404    0.8473
 0.804304  0.337434  0.58761   0.994204     0.353217  0.0582558  0.646654
 0.574554  0.161881  0.320669  0.392994     0.313239  0.539354   0.322451
 0.228284  0.587288  0.98003   0.916057     0.773928  0.856786   0.150898</code></pre><p>With <code>ClimArray</code> you can use convenience, physically-inspired functions that do automatic (and correct) weighting. For example the latitudinal mean of <code>B</code> is simply</p><pre><code class="language-julia hljs">C = latmean(B)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ClimArray with dimensions:
  Lon (Longitude): 0:10:30 Sampled: Ordered Regular Points
and data: 4-element Vector{Float64}
[0.477022, 0.4428, 0.428898, 0.58786]</code></pre><p>where in this averaging process each data point is weighted by the cosine of its latitude.</p><h3 id="Making-a-ClimArray"><a class="docs-heading-anchor" href="#Making-a-ClimArray">Making a <code>ClimArray</code></a><a id="Making-a-ClimArray-1"></a><a class="docs-heading-anchor-permalink" href="#Making-a-ClimArray" title="Permalink"></a></h3><p>You can create a <code>ClimArray</code> yourself, or you can load data from an <code>.nc</code> file with CF-conventions, see <a href="#NetCDF-IO">NetCDF IO</a>.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}" href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimateBase.ClimArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ClimArray(A::Array, dims::Tuple; name = &quot;&quot;, attrib = nothing)</code></pre><p><code>ClimArray</code> is a structure that contains numerical array data bundled with dimensional information, a name and an <code>attrib</code> field (typically a dictionary) that holds general attributes. You can think of <code>ClimArray</code> as a in-memory representation of a CFVariable.</p><p>At the moment, a <code>ClimArray</code> is using <code>DimensionalArray</code> from DimensionalData.jl, and all basic handling of <code>ClimArray</code> is offered by <code>DimensionalData</code> (see below).</p><p><code>ClimArray</code> is created by passing in standard array data <code>A</code> and a tuple of dimensions <code>dims</code>. See <a href="#ClimateBase.ncread"><code>ncread</code></a> to automatically create a <code>ClimArray</code> from a .nc file.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using ClimateBase, Dates
Time = ClimateBase.Ti # more intuitive name for time dimension
lats = -90:5:90
lons = 0:10:359
t = Date(2000, 3, 15):Month(1):Date(2020, 3, 15)
# dimensional information:
dimensions = (Lon(lons), Lat(lats), Time(t))
data = rand(36, 37, 241) # numeric data
A = ClimArray(data, dimensions)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/436bb6fe2de6cfe0963345b8c2ddeb0564f2178e/src/core/coredefs.jl#L130-L157">source</a></section></article><p>It is strongly recommended to use the dimensions we export (because we dispatch on them and use their information):</p><pre><code class="language-julia hljs">for D in ClimateBase.STANDARD_DIMS
    println(D, &quot; (full name = $(DimensionalData.name(D)))&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Lon (full name = Longitude)
Lat (full name = Latitude)
Ti (full name = Time)
Hei (full name = Height)
Pre (full name = Pressure)
Coord (full name = )</code></pre><p>We explicitly assume that <code>Lon, Lat</code> are measured in degrees and not radians or meters (extremely important for spatial averaging processes).</p><h2 id="NetCDF-IO"><a class="docs-heading-anchor" href="#NetCDF-IO">NetCDF IO</a><a id="NetCDF-IO-1"></a><a class="docs-heading-anchor-permalink" href="#NetCDF-IO" title="Permalink"></a></h2><p>ClimateBase.jl has support for <code>file.nc ⇆ ClimArray</code>. Usually this is done using NCDatasets.jl, but see below for a function that translates a loaded <code>xarray</code> (from Python) into <code>ClimArray</code>.</p><h3 id="Read"><a class="docs-heading-anchor" href="#Read">Read</a><a id="Read-1"></a><a class="docs-heading-anchor-permalink" href="#Read" title="Permalink"></a></h3><p>To load a <code>ClimArray</code> directly from an <code>.nc</code> file do:</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ncread" href="#ClimateBase.ncread"><code>ClimateBase.ncread</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ncread(file, var [, selection]; kwargs...) → A</code></pre><p>Load the variable <code>var</code> from the <code>file</code> and convert it into a <a href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimArray</code></a> with proper dimension mapping and also containing the variable attributes as a dictionary. Dimension attributes are also given to the dimensions of <code>A</code>, if any exist.  See keywords below for specifications for unstructured grids.</p><p><code>file</code> can be a string to a <code>.nc</code> file. Or, it can be an <code>NCDataset</code>, which allows you to lazily combine different <code>.nc</code> data (typically split by time), e.g.</p><pre><code class="language-julia hljs">using Glob # for getting all files
alldata = glob(&quot;toa_fluxes_*.nc&quot;)
file = NCDataset(alldata; aggdim = &quot;time&quot;)
A = ClimArray(file, &quot;tow_sw_all&quot;)</code></pre><p><code>var</code> is a <code>String</code> denoting which variable to load. For <code>.nc</code> data containing groups <code>var</code> can also be a tuple <code>(&quot;group_name&quot;, &quot;var_name&quot;)</code> that loads a specific variable from a specific group. In this case, the attributes of both the group and the CF-variable are attributed to the created <a href="#ClimateBase.ClimArray-Tuple{AbstractArray, Tuple}"><code>ClimArray</code></a>.</p><p>Optionally you can provide a <code>selection</code> for selecting a smaller part of the full array. The <code>selection</code> must be a tuple of indices that compose the selection and you must specify exactly as many ranges as the dimensions of the array and in the correct order. For example, if <code>var</code> corresponds to an array with three dimensions, such syntaxes are possible:</p><pre><code class="language-julia hljs">(:, :, 1:3)
(1:5:100, 1:1, [1,5,6])</code></pre><p>See also <a href="#ClimateBase.ncdetails"><code>ncdetails</code></a>, <a href="#ClimateBase.nckeys"><code>nckeys</code></a> and <a href="#ClimateBase.ncwrite"><code>ncwrite</code></a>.</p><p><strong>Smart loading</strong></p><p>The following things make loading data with <code>ncread</code> smarter than directly trying to use NCDatasets.jl and then convert to some kind of dimensional container.</p><ol><li>Data are directly transformed into <code>ClimArray</code>, conserving metadata and dimension names.</li><li>If there are no missing values in the data (according to CF standards), the returned array is automatically converted to a concrete type (i.e. <code>Union{Float32, Missing}</code> becomes <code>Float32</code>).</li><li>Dimensions that are ranges (i.e. sampled with constant step size) are automatically transformed to a standard Julia <code>Range</code> type (which makes sub-selecting faster).</li><li>Automatically deducing whether the spatial information is in an orthogonal grid or not, and creating a single <code>Coord</code> dimension if not.</li></ol><p><strong>Keywords</strong></p><ul><li><code>name</code> optionally rename loaded array.</li><li><code>grid = nothing</code> optionally specify whether the underlying grid is <code>grid = LonLatGrid()</code> or <code>grid = UnstructuredGrid()</code>, see <a href="statistics/#Types-of-spatial-coordinates">Types of spatial coordinates</a>. If <code>nothing</code>, we try to deduce automatically based on the names of dimensions and other keys of the <code>NCDataset</code>.</li><li><code>lon, lat</code>. These two keywords are useful in unstructured grid data where the grid information is provided in a <em>separate .nc file</em>. What we need is the user to provide vectors of the central longitude and central latitude of each grid point. This is done e.g. by<pre><code class="language-julia hljs">ds = NCDataset(&quot;path/to/grid.nc&quot;);
lon = Array(ds[&quot;clon&quot;]);
lat = Array(ds[&quot;clat&quot;]);</code></pre>If <code>lon, lat</code> are given, <code>grid</code> is automatically assumed <code>UnstructuredGrid()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/436bb6fe2de6cfe0963345b8c2ddeb0564f2178e/src/core/nc_io.jl#L55-L118">source</a></section></article><p>Notice that (at the moment) we use a pre-defined mapping of common names to proper dimensions - please feel free to extend the following via a Pull Request:</p><pre><code class="language-julia hljs">ClimateBase.COMMONNAMES</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, UnionAll} with 16 entries:
  &quot;lat&quot;       =&gt; Lat
  &quot;altitude&quot;  =&gt; Hei
  &quot;time&quot;      =&gt; Ti
  &quot;pressure&quot;  =&gt; Pre
  &quot;xc&quot;        =&gt; Lon
  &quot;x&quot;         =&gt; Lon
  &quot;lon&quot;       =&gt; Lon
  &quot;age&quot;       =&gt; Ti
  &quot;level&quot;     =&gt; Pre
  &quot;latitude&quot;  =&gt; Lat
  &quot;height&quot;    =&gt; Hei
  &quot;long&quot;      =&gt; Lon
  &quot;longitude&quot; =&gt; Lon
  &quot;t&quot;         =&gt; Ti
  &quot;yc&quot;        =&gt; Lat
  &quot;y&quot;         =&gt; Lat</code></pre><p>Also, the following convenience functions are provided for examining the content of on-disk <code>.nc</code> files without loading all data on memory.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.nckeys" href="#ClimateBase.nckeys"><code>ClimateBase.nckeys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nckeys(file::String)</code></pre><p>Return all keys of the <code>.nc</code> file in <code>file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/436bb6fe2de6cfe0963345b8c2ddeb0564f2178e/src/core/nc_io.jl#L20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ncdetails" href="#ClimateBase.ncdetails"><code>ClimateBase.ncdetails</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ncdetails(file::String, io = stdout)</code></pre><p>Print details about the <code>.nc</code> file in <code>file</code> on <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/436bb6fe2de6cfe0963345b8c2ddeb0564f2178e/src/core/nc_io.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.globalattr" href="#ClimateBase.globalattr"><code>ClimateBase.globalattr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">globalattr(file::String) → Dict</code></pre><p>Return the global attributes of the .nc file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/436bb6fe2de6cfe0963345b8c2ddeb0564f2178e/src/core/nc_io.jl#L42-L45">source</a></section></article><h3 id="Write"><a class="docs-heading-anchor" href="#Write">Write</a><a id="Write-1"></a><a class="docs-heading-anchor-permalink" href="#Write" title="Permalink"></a></h3><p>You can also write a bunch of <code>ClimArray</code>s directly into an <code>.nc</code> file with</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ncwrite" href="#ClimateBase.ncwrite"><code>ClimateBase.ncwrite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ncwrite(file::String, Xs; globalattr = Dict())</code></pre><p>Write the given <code>ClimArray</code> instances (any iterable of <code>ClimArray</code>s or a single <code>ClimArray</code>) to a <code>.nc</code> file following CF standard conventions using NCDatasets.jl. Optionally specify global attributes for the <code>.nc</code> file.</p><p>The metadata of the arrays in <code>Xs</code>, as well as their dimensions, are properly written in the <code>.nc</code> file and any necessary type convertions happen automatically.</p><p><strong>WARNING</strong>: We assume that any dimensions shared between the <code>Xs</code> are identical.</p><p>See also <a href="#ClimateBase.ncread"><code>ncread</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/436bb6fe2de6cfe0963345b8c2ddeb0564f2178e/src/core/nc_io.jl#L442-L454">source</a></section></article><h3 id="xarray"><a class="docs-heading-anchor" href="#xarray">xarray</a><a id="xarray-1"></a><a class="docs-heading-anchor-permalink" href="#xarray" title="Permalink"></a></h3><p>You can use the following functions (which are not defined and exported in <code>ClimateBase</code> to avoid dependency on PyCall.jl) to load data using Python&#39;s <code>xarray</code>.</p><pre><code class="language-julia hljs">using ClimateBase, Dates
# This needs to numpy, xarray and dask installed from Conda
using PyCall
xr = pyimport(&quot;xarray&quot;)
np = pyimport(&quot;numpy&quot;)

function climarray_from_xarray(xa, fieldname, name = fieldname)
    w = getproperty(xa, Symbol(fieldname))
    raw_data = Array(w.values)
    dnames = collect(w.dims) # dimensions in string name
    dim_values, dim_attrs = extract_dimension_values_xarray(xa, dnames)
    @assert collect(size(raw_data)) == length.(dim_values)
    actual_dims = create_dims_xarray(dnames, dim_values, dim_attrs)
    ca = ClimArray(raw_data, actual_dims, name; attrib = w.attrs)
end

function extract_dimension_values_xarray(xa, dnames = collect(xa.dims))
    dim_values = []
    dim_attrs = Vector{Any}(fill(nothing, length(dnames)))
    for (i, d) in enumerate(dnames)
        dim_attrs[i] = getproperty(xa, d).attrs
        x = getproperty(xa, d).values
        if d ≠ &quot;time&quot;
            push!(dim_values, x)
        else
            dates = [np.datetime_as_string(y)[1:19] for y in x]
            dates = DateTime.(dates)
            push!(dim_values, dates)
        end
    end
    return dim_values, dim_attrs
end

function create_dims_xarray(dnames, dim_values, dim_attrs)
    true_dims = ClimateBase.to_proper_dimensions(dnames)
    optimal_values = ClimateBase.vector2range.(dim_values)
    out = []
    for i in 1:length(true_dims)
        push!(out, true_dims[i](optimal_values[i]; metadata = dim_attrs[i]))
    end
    return (out...,)
end

# Load some data
xa = xr.open_mfdataset(ERA5_files_path)
X = climarray_from_xarray(xa, &quot;w&quot;, &quot;optional name&quot;)</code></pre><h2 id="Ensemble-types"><a class="docs-heading-anchor" href="#Ensemble-types">Ensemble types</a><a id="Ensemble-types-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-types" title="Permalink"></a></h2><p>A dedicated type representing ensembles has no reason to exist in ClimateBase.jl. As the package takes advantage of standard Julia datastructures and syntax, those can be used to represent &quot;ensembles&quot;. For example to do an &quot;ensemble global mean&quot; you can just do:</p><pre><code class="language-julia hljs"># load all data
E = [ClimArray(&quot;ensemble_$i.nc&quot;, &quot;x&quot;) for i in 1:10]
# mean from all data
global_mean = mean(spacemean(X) for X in E)</code></pre><p>where you see that the &quot;ensemble&quot; was represented just as a <code>Vector{ClimArray}</code>. Of course, this requires that all data can fit into memory, but this is so far the only way ClimateBase.jl operates anyways.</p><h2 id="Crash-course-to-DimensionalData.jl"><a class="docs-heading-anchor" href="#Crash-course-to-DimensionalData.jl">Crash-course to DimensionalData.jl</a><a id="Crash-course-to-DimensionalData.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Crash-course-to-DimensionalData.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData" href="#DimensionalData"><code>DimensionalData</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>DimensionalData</strong></p><p><a href="https://rafaqz.github.io/DimensionalData.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://rafaqz.github.io/DimensionalData.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <img src="https://github.com/rafaqz/DimensionalData.jl/workflows/CI/badge.svg" alt="CI"/> <a href="https://codecov.io/gh/rafaqz/DimensionalData.jl"><img src="https://codecov.io/gh/rafaqz/DimensionalData.jl/branch/master/graph/badge.svg" alt="Codecov"/></a> <a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://img.shields.io/badge/Aqua.jl-%F0%9F%8C%A2-aqua.svg" alt="Aqua.jl Quality Assurance"/></a></p><p>DimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions, and optionally a lookup index. It&#39;s a pluggable,  generalised version of <a href="https://github.com/JuliaArrays/AxisArrays.jl">AxisArrays.jl</a>  with a cleaner syntax, and additional functionality found in NamedDims.jl. It has  similar goals to pythons <a href="http://xarray.pydata.org/en/stable/">xarray</a>, and is primarily written for use with spatial data in <a href="https://github.com/rafaqz/GeoData.jl">GeoData.jl</a>.</p><p>Broadcasting and most Base methods maintain and sync dimension context.</p><p>DimensionalData.jl also implements:</p><ul><li>comprehensive plot recipes for Plots.jl.</li><li>a Tables.jl interface with <code>DimTable</code></li><li>multi-layered <code>DimStack</code>s that can be indexed together,    and have base methods applied to all layers.</li><li>the Adapt.jl interface for use on GPUs, even as GPU kernel arguments.</li><li>traits for handling a wide range of spatial data types accurately.</li></ul><p><strong>Dimensions</strong></p><p>Dimensions are wrapper types. They hold the lookup index, details about the  grid, and other metadata. They are also used to index into the array.  <code>X</code>, <code>Y</code>, <code>Z</code> and <code>Ti</code> are the exported defaults. A generalised <code>Dim</code> type is available  to use arbitrary symbols to name dimensions. Custom dimension types can also be defined  using the <code>@dim</code> macro.</p><p>Dimensions can be used to construct arrays in <code>rand</code>, <code>ones</code>, <code>zeros</code> and <code>fill</code> with  either a range for a lookup index or a number for the dimension length:</p><pre><code class="language-julia hljs">julia&gt; using DimensionalData

julia&gt; A = rand(X(1:40), Y(50))
40×50 DimArray{Float64,2} with dimensions:
  X: 1:40 (Sampled - Ordered Regular Points)
  Y
 0.929006   0.116946  0.750017  …  0.172604  0.678835   0.495294
 0.0550038  0.100739  0.427026     0.778067  0.309657   0.831754
 ⋮                              ⋱
 0.647768   0.965682  0.049315     0.220338  0.0326206  0.36705
 0.851769   0.164914  0.555637     0.771508  0.964596   0.30265</code></pre><p>We can also use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:</p><pre><code class="language-julia hljs">julia&gt; A[Y(1), X(1:10)]
10-element DimArray{Float64,1} with dimensions:
  X: 1:10 (Sampled - Ordered Regular Points)
and reference dimensions: Y(1) 
 0.929006
 0.0550038
 0.641773
 ⋮
 0.846251
 0.506362
 0.0492866</code></pre><p>And this has no runtime cost:</p><pre><code class="language-julia hljs">julia&gt; A = ones(X(3), Y(3))
3×3 DimArray{Float64,2} with dimensions: X, Y
 1.0  1.0  1.0
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; @btime $A[X(1), Y(2)]
  1.077 ns (0 allocations: 0 bytes)
1.0

julia&gt; @btime parent($A)[1, 2]
  1.078 ns (0 allocations: 0 bytes)
1.0</code></pre><p>Dims can be used in <code>X=val</code> form:</p><pre><code class="language-julia hljs">julia&gt; A = rand(X(40), Y(50))
40×50 DimArray{Float64,2} with dimensions: X, Y
 0.377696  0.105445  0.543156  …  0.844973  0.163758  0.849367
 ⋮                             ⋱
 0.431454  0.108927  0.137541     0.531587  0.592512  0.598927

julia&gt; A[Y=3]
40-element DimArray{Float64,1} with dimensions: X
and reference dimensions: Y(3)
 0.543156
 ⋮
 0.137541</code></pre><p>For views:</p><pre><code class="language-julia hljs">julia&gt; view(A, Y(), X(1:5))
5×50 DimArray{Float64,2} with dimensions: X, Y
 0.377696  0.105445  0.543156  …  0.844973  0.163758  0.849367
 ⋮                             ⋱
 0.875279  0.133032  0.925045     0.156768  0.736917  0.444683</code></pre><p>And for specifying dimension number in all <code>Base</code> and <code>Statistics</code>  functions that have a <code>dims</code> argument:</p><pre><code class="language-julia hljs">julia&gt; using Statistics

julia&gt; A = rand(X(3), Y(4), Ti(5));

julia&gt; mean(A; dims=Ti)
3×4×1 DimArray{Float64,3} with dimensions: X, Y, Ti (Time)
[:, :, 1]
 0.168058  0.52353   0.563065  0.347025
 0.472786  0.395884  0.307846  0.518926
 0.365028  0.381367  0.423553  0.369339</code></pre><p>You can also use symbols to create <code>Dim{X}</code> dimensions. We can&#39;t use the <code>rand</code> method directly with Symbols, so insteadd use the regular <code>DimArray</code> constructor:</p><pre><code class="language-julia hljs">julia&gt; A = DimArray(rand(10, 20, 30), (:a, :b, :c));

julia&gt; A[a=2:5, c=9]

4×20 DimArray{Float64,2} with dimensions: Dim{:a}, Dim{:b}
and reference dimensions: Dim{:c}(9)
 0.134354  0.581673  0.422615  …  0.410222   0.687915  0.753441
 0.573664  0.547341  0.835962     0.0353398  0.794341  0.490831
 0.166643  0.133217  0.879084     0.695685   0.956644  0.698638
 0.325034  0.147461  0.149673     0.560843   0.889962  0.75733</code></pre><p><strong>Selectors</strong></p><p>Selectors find indices in the lookup index, for each dimension: </p><ul><li><code>At(x)</code>: get the index exactly matching the passed in value(s)</li><li><code>Near(x)</code>: get the closest index to the passed in value(s)</li><li><code>Where(f::Function)</code>: filter the array axis by a function of the    dimension index values.</li><li><code>Between(a, b)</code>: get all indices between two values, excluding the high value.</li><li><code>Contains(x)</code>: get indices where the value x falls within the interval, exluding    the upper value. Only used for <code>Sampled</code> <code>Intervals</code>, for <code>Points</code>, use <code>At</code>.</li></ul><p>(<code>Between</code> and <code>Contains</code> exlude the upper boundary so that adjacent selections never contain the same index)</p><p>Selectors can be used in <code>getindex</code>, <code>setindex!</code> and <code>view</code> to select indices matching the passed in value(s)</p><p>We can use selectors inside dim wrappers:</p><pre><code class="language-julia hljs">julia&gt; using Dates

julia&gt; timespan = DateTime(2001,1):Month(1):DateTime(2001,12)
DateTime(&quot;2001-01-01T00:00:00&quot;):Month(1):DateTime(&quot;2001-12-01T00:00:00&quot;)

julia&gt; A = DimArray(rand(12,10), (Ti(timespan), X(10:10:100)))
12×10 DimArray{Float64,2} with dimensions:
  Ti (Time): DateTime(&quot;2001-01-01T00:00:00&quot;):Month(1):DateTime(&quot;2001-12-01T00:00:00&quot;) (Sampled - Ordered Regular Points)
  X: 10:10:100 (Sampled - Ordered Regular Points)
 0.14106   0.476176  0.311356  0.454908  …  0.464364  0.973193  0.535004
 ⋮                                       ⋱
 0.522759  0.390414  0.797637  0.686718     0.901123  0.704603  0.0740788

julia&gt; @btime A[X(Near(35)), Ti(At(DateTime(2001,5)))]
0.3133109280208961</code></pre><p>Without dim wrappers selectors must be in the right order:</p><pre><code class="language-julia hljs">using Unitful

julia&gt; A = rand(X((1:10:100)u&quot;m&quot;), Ti((1:5:100)u&quot;s&quot;));

julia&gt; A[Between(10.5u&quot;m&quot;, 50.5u&quot;m&quot;), Near(23u&quot;s&quot;)]
4-element DimArray{Float64,1} with dimensions:
  X: (11:10:41) m (Sampled - Ordered Regular Points)
and reference dimensions:
  Ti(21 s) (Time): 21 s (Sampled - Ordered Regular Points)
 0.584028
 ⋮
 0.716715</code></pre><p><strong>Methods where dims can be used containing indices or Selectors</strong></p><p><code>getindex</code>, <code>setindex!</code> <code>view</code></p><p><strong>Methods where dims, dim types, or <code>Symbol</code>s can be used to indicate the array dimension:</strong></p><ul><li><code>size</code>, <code>axes</code>, <code>firstindex</code>, <code>lastindex</code></li><li><code>cat</code>, <code>reverse</code>, <code>dropdims</code></li><li><code>reduce</code>, <code>mapreduce</code></li><li><code>sum</code>, <code>prod</code>, <code>maximum</code>, <code>minimum</code>,</li><li><code>mean</code>, <code>median</code>, <code>extrema</code>, <code>std</code>, <code>var</code>, <code>cor</code>, <code>cov</code></li><li><code>permutedims</code>, <code>adjoint</code>, <code>transpose</code>, <code>Transpose</code></li><li><code>mapslices</code>, <code>eachslice</code></li></ul><p><strong>Methods where dims can be used to construct <code>DimArray</code>s:</strong></p><ul><li><code>fill</code>, <code>ones</code>, <code>zeros</code>, <code>rand</code></li></ul><p><strong>Warnings</strong></p><p>Indexing with unordered or reverse order arrays has undefined behaviour. It will trash the dimension index, break <code>searchsorted</code> and nothing will make sense any more. So do it at you own risk. However, indexing with sorted vectors of Int can be useful. So it&#39;s allowed. But it will still do strange things to your interval sizes if the dimension span is <code>Irregular</code>.</p><p><strong>Alternate Packages</strong></p><p>There are a lot of similar Julia packages in this space. AxisArrays.jl, NamedDims.jl, NamedArrays.jl are registered alternative that each cover some of the functionality provided by DimensionalData.jl. DimensionalData.jl should be able to replicate most of their syntax and functionality.</p><p><a href="https://github.com/mcabbott/AxisKeys.jl">AxisKeys.jl</a> and <a href="https://github.com/Tokazama/AbstractIndices.jl">AbstractIndices.jl</a> are some other interesting developments. For more detail on why there are so many similar options and where things are headed, read this <a href="https://github.com/JuliaCollections/AxisArraysFuture/issues/1">thread</a>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="statistics/">Statistics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 3 January 2022 18:19">Monday 3 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
