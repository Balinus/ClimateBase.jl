<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · ClimateBase</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Quicksand|Montserrat|Source+Code+Pro|Lora&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ClimateBase</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#ClimArray:-the-core-data-structure"><span><code>ClimArray</code>: the core data structure</span></a></li><li><a class="tocitem" href="#Making-a-ClimArray"><span>Making a <code>ClimArray</code></span></a></li><li><a class="tocitem" href="#Temporal"><span>Temporal</span></a></li><li><a class="tocitem" href="#Spatial"><span>Spatial</span></a></li><li><a class="tocitem" href="#General-aggregation"><span>General aggregation</span></a></li><li><a class="tocitem" href="#Timeseries-Analysis"><span>Timeseries Analysis</span></a></li><li><a class="tocitem" href="#Climate-quantities"><span>Climate quantities</span></a></li><li><a class="tocitem" href="#Crash-course-to-DimensionalData.jl"><span>Crash-course to DimensionalData.jl</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p><code>ClimateBase</code> is a Julia package offering basic functionality for analyzing data that are typically in the form used by climate sciences. These data are dimensional &amp; spatiotemporal but the corresponding dimensions all need special handling. For example the most common dimensions are longitude, latitude and time.</p><ul><li>longitude is by definition a periodic dimension</li><li>latitude is a linear dimension. However because the coordinate system most often used in climate sciences is a grid of longitude × latitude (in equal degrees) the area element of space depends on latitude and this needs to be taken into account.</li><li>time is a linear dimension <em>in principle</em>, but its values are <code>&lt;: AbstractDateTime</code> instead of <code>&lt;: Real</code>. The human calendar (where these values come from) is periodic but each period may not correspond to the same physical time, and this also needs to be taken into account.</li></ul><p><code>ClimateBase</code> is structured to deal with these intricacies, and in addition offer several functionalities commonly used, and sought after, by climate scientists. It also serves as the base building block for <code>ClimateTools</code>, which offers more advanced functionalities.</p><p>The focus of <code>ClimateBase</code> is <strong>not</strong> loading data, nor operating on data <em>on disk</em>. It is designed for in-memory climate data exploration and manipulation. That being said, basic data loading functionality is offered in terms of <code>NCDatasets</code>, see below.</p><h2 id="ClimArray:-the-core-data-structure"><a class="docs-heading-anchor" href="#ClimArray:-the-core-data-structure"><code>ClimArray</code>: the core data structure</a><a id="ClimArray:-the-core-data-structure-1"></a><a class="docs-heading-anchor-permalink" href="#ClimArray:-the-core-data-structure" title="Permalink"></a></h2><p>This project treats &quot;climate data&quot; as a <a href="#ClimateBase.ClimArray-Tuple{AbstractArray,Tuple}"><code>ClimArray</code></a>, which uses the DimensionalData.jl interface. <code>ClimArray</code> is <em>almost</em> equivalent to <code>DimensionalArray</code>. A (brief) introduction to DimensionalData.jl is copied here from its docs, because basic knowledge of how to handle a <code>ClimArray</code> is assumed in our docs.</p><p>DimensionalData.jl allows truly convenient handling of climate data, where it is important to be able to dimensionally-index data by their values.</p><p>E.g. you can create an array with</p><pre><code class="language-julia">using ClimateBase, Dates
Time = ClimateBase.Ti # more intuitive
lats = -90:5:90
lons = 0:10:359
t = Date(2000, 3, 15):Month(1):Date(2020, 3, 15)
dimensions = (Lon(lons), Lat(lats), Time(t))
A = ClimArray(rand(36, 37, 241), dimensions)</code></pre><pre class="documenter-example-output">ClimArray with dimensions:
 Longitude (type Lon): 0:10:350 (Sampled: Ordered Regular Points)
 Latitude (type Lat): -90:5:90 (Sampled: Ordered Regular Points)
 Time (type Ti): Dates.Date(&quot;2000-03-15&quot;):Dates.Month(1):Dates.Date(&quot;2020-03-15&quot;) (Sampled: Ordered Regular Points)
and data: 36×37×241 Array{Float64,3}
[:, :, 1]
 0.0876897  0.201045   0.935073  …  0.226032    0.125742   0.705896
 0.814606   0.693575   0.12523      0.00134379  0.57715    0.0998346
 0.636126   0.500199   0.703458     0.998609    0.671763   0.643162
 0.321499   0.0778252  0.338908     0.723414    0.802767   0.400883
 0.49755    0.352684   0.448589     0.268722    0.137295   0.270989
 0.390133   0.576086   0.722358  …  0.54913     0.500972   0.850065
 0.424472   0.0685219  0.500821     0.183735    0.483822   0.721906
 0.667468   0.340463   0.9907       0.230099    0.310885   0.656328
 0.482551   0.231879   0.344545     0.0026395   0.202266   0.775876
 0.785026   0.464519   0.717387     0.849002    0.658123   0.302229
 ⋮                               ⋱              ⋮          
 0.2498     0.49667    0.774837     0.588329    0.168151   0.786255
 0.202715   0.284298   0.604669     0.300084    0.892308   0.740032
 0.513604   0.821093   0.142669     0.936724    0.586051   0.273417
 0.959253   0.99284    0.267682  …  0.590566    0.963457   0.468882
 0.677312   0.0454788  0.74414      0.848854    0.797178   0.865123
 0.418081   0.133939   0.478855     0.144786    0.0749549  0.102711
 0.547283   0.988893   0.358046     0.0707347   0.8314     0.362046
 0.64731    0.800457   0.292898     0.740662    0.170388   0.170457
 0.913403   0.580314   0.50088   …  0.0844546   0.533685   0.682081
[and 240 more slices...]</pre><p>and then select a specific timeslice at <code>Date(2011,5,15)</code> and a longitude interval between 0 and 30 degrees like so:</p><pre><code class="language-julia">B = A[Lon(Between(0, 30)), Time(At(Date(2011,5,15)))]</code></pre><pre class="documenter-example-output">ClimArray with dimensions:
 Longitude (type Lon): 0:10:30 (Sampled: Ordered Regular Points)
 Latitude (type Lat): -90:5:90 (Sampled: Ordered Regular Points)
and data: 4×37 Array{Float64,2}
 0.723315   0.415599  0.852796  0.589696  …  0.429806  0.802906  0.362976
 0.0666835  0.795066  0.116225  0.791404     0.87519   0.412869  0.735704
 0.358497   0.908629  0.8405    0.554415     0.411423  0.91664   0.991208
 0.157235   0.264367  0.365243  0.75714      0.549304  0.20899   0.800125</pre><p>With <code>ClimArray</code> you can use convenience, physically-inspired functions that do automatic (and correct) weighting. For example the latitudinal mean of <code>B</code> is simply</p><pre><code class="language-julia">C = latmean(B)</code></pre><pre class="documenter-example-output">ClimArray with dimensions:
 Longitude (type Lon): 0:10:30 (Sampled: Ordered Regular Points)
and data: 4-element Array{Float64,1}
[0.443713, 0.522078, 0.487632, 0.56642]</pre><p>where in this averaging process each data point is weighted by the cosine of its latitude.</p><h2 id="Making-a-ClimArray"><a class="docs-heading-anchor" href="#Making-a-ClimArray">Making a <code>ClimArray</code></a><a id="Making-a-ClimArray-1"></a><a class="docs-heading-anchor-permalink" href="#Making-a-ClimArray" title="Permalink"></a></h2><p>You can create a <code>ClimArray</code> yourself, or you can load data from an <code>.nc</code> file with CF-conventions, using <code>ClimArray</code>.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ClimArray-Tuple{AbstractArray,Tuple}" href="#ClimateBase.ClimArray-Tuple{AbstractArray,Tuple}"><code>ClimateBase.ClimArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ClimArray(A::Array, dims::Tuple; name = &quot;&quot;, attrib = nothing)</code></pre><p><code>ClimArray</code> is a structure that contains numerical array data bundled with dimensional information, a name and an <code>attrib</code> field (typically a dictionary) that holds general attributes. You can think of <code>ClimArray</code> as a in-memory representation of a CFVariable.</p><p>At the moment, a <code>ClimArray</code> is using <code>DimensionalArray</code> from DimensionalData.jl, and all basic handling of <code>ClimArray</code> is offered by <code>DimensionalData</code> (see below).</p><p><code>ClimArray</code> is created by passing in standard array data <code>A</code> and a tuple of dimensions <code>dims</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ClimateBase, Dates
Time = ClimateBase.Ti # more intuitive name for time dimension
lats = -90:5:90
lons = 0:10:359
t = Date(2000, 3, 15):Month(1):Date(2020, 3, 15)
# dimensional information:
dimensions = (Lon(lons), Lat(lats), Time(t))
data = rand(36, 37, 241) # numeric data
A = ClimArray(data, dimensions)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/core/coredefs.jl#L83-L108">source</a></section></article><p>It is strongly recommended to use the dimensions we export (because we dispatch on them and use their information):</p><pre><code class="language-julia">for D in ClimateBase.STANDARD_DIMS
    println(D, &quot; (full name = $(DimensionalData.name(D)))&quot;)
end</code></pre><pre class="documenter-example-output">Lon (full name = Longitude)
Lat (full name = Latitude)
Ti (full name = Time)
Hei (full name = Height)
Pre (full name = Pressure)
Coord (full name = Spatial Coordinates)</pre><p>We explicitly assume that <code>Lon, Lat</code> are measured in degrees and not radians or meters (extremely important for spatial averaging processes).</p><hr/><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ClimArray-Tuple{Union{Array{String,1}, String}}" href="#ClimateBase.ClimArray-Tuple{Union{Array{String,1}, String}}"><code>ClimateBase.ClimArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ClimArray(file::NCDataset, var::String, name = var) -&gt; A</code></pre><p>Load the variable <code>var</code> from the <code>file</code> and convert it into a <code>ClimArray</code> which also contains the variable attributes as a dictionary.</p><p>Notice that <code>file</code> should be an <code>NCDataset</code>, which allows you to lazily combine different <code>.nc</code> data (typically split by time), e.g.</p><pre><code class="language-julia">alldata = [&quot;toa_fluxes_2020_$(i).nc&quot; for i in 1:12]
file = NCDataset(alldata; aggdim = &quot;time&quot;)
A = ClimArray(file, &quot;tow_sw_all&quot;)</code></pre><p>(of course you can just do <code>NCDataset(&quot;file.nc&quot;)</code> for single files).</p><p>We do two performance improvements while loading the data:</p><ol><li>If there are no missing values in the data (according to CF standards), the returned array is automatically converted to a concrete type (i.e. <code>Union{Float32, Missing}</code> becomes <code>Float32</code>).</li><li>Dimensions that are ranges (i.e. sampled with constant step size) are automatically transformed to a standard Julia <code>Range</code> type (which makes sub-selecting faster).</li></ol><p>At the moment, support for auto-loading equal area space types does not exist, see <a href="#Types-of-spatial-coordinates">Types of spatial coordinates</a>. But you can easily transform them yourself into a <code>ClimArray</code> by doing e.g.:</p><pre><code class="language-julia">file = NCDataset(&quot;some_file_with_eqarea.nc&quot;)
lons = file[&quot;lon&quot;]
lats = file[&quot;lat&quot;]
coords = [SVector(lo, la) for (lo, la) in zip(lons, lats)]
t = file[&quot;time&quot;]
dimensions = (Coord(coords), Time(t))
data = file[&quot;actual_data_like_radiation&quot;]
A = ClimArray(data, dimensions)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/core/loading_nc.jl#L34-L69">source</a></section></article><p>Notice that (at the moment) we use a pre-defined mapping of common names to proper dimensions - please feel free to extend the following via a Pull Request:</p><pre><code class="language-julia">ClimateBase.COMMONNAMES</code></pre><pre class="documenter-example-output">Dict{String,UnionAll} with 10 entries:
  &quot;lat&quot;       =&gt; Lat
  &quot;latitude&quot;  =&gt; Lat
  &quot;height&quot;    =&gt; Hei
  &quot;long&quot;      =&gt; Lon
  &quot;time&quot;      =&gt; Ti
  &quot;altitude&quot;  =&gt; Hei
  &quot;pressure&quot;  =&gt; Pre
  &quot;longitude&quot; =&gt; Lon
  &quot;lon&quot;       =&gt; Lon
  &quot;level&quot;     =&gt; Pre</pre><p>Also, two convenience functions are provided for examining the content of on-disk <code>.nc</code> files without loading all data on memory.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.nckeys" href="#ClimateBase.nckeys"><code>ClimateBase.nckeys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nckeys(file::String)</code></pre><p>Return all keys of the <code>.nc</code> file in <code>file</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/core/loading_nc.jl#L12-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.ncdetails" href="#ClimateBase.ncdetails"><code>ClimateBase.ncdetails</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ncdetails(file::String, io = stdout)</code></pre><p>Print details about the <code>.nc</code> file in <code>file</code> on <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/core/loading_nc.jl#L23-L26">source</a></section></article><h2 id="Temporal"><a class="docs-heading-anchor" href="#Temporal">Temporal</a><a id="Temporal-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal" title="Permalink"></a></h2><p>Functions related with the <code>Time</code> dimension.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.timemean" href="#ClimateBase.timemean"><code>ClimateBase.timemean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timemean(A::ClimArray [, w]) = timeagg(mean, A, w)</code></pre><p>Temporal average of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/temporal.jl#L161-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.timeagg" href="#ClimateBase.timeagg"><code>ClimateBase.timeagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">timeagg(f, A::ClimArray, W = nothing)</code></pre><p>Perform a proper temporal aggregation of the function <code>f</code> (e.g. <code>mean, std</code>) on <code>A</code> (assuming monthly spaced data) where:</p><ul><li>Only full year spans of <code>A</code> are included, see <a href="#ClimateBase.maxyearspan"><code>maxyearspan</code></a> (because most processes are affected by yearly cycle, and averaging over an uneven number of cycles typically results in artifacts)</li><li>Each month in <code>A</code> is weighted with its length in days (for monthly sampled data)</li></ul><p>If you don&#39;t want these features, just do <a href="#ClimateBase.dropagg"><code>dropagg</code></a><code>(f, A, Time, W)</code>.</p><p><code>W</code> are possible statistical weights that are used in conjuction to the temporal weighting, to weight each time point differently. If they are not a vector (a weight for each time point), then they have to be a dimensional array of same dimensional layout as <code>A</code> (a weight for each data point).</p><pre><code class="language-none">timeagg(f, t::Vector, x::Vector, w = nothing)</code></pre><p>Same as above, but for arbitrary vector <code>x</code> accompanied by time vector <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/temporal.jl#L168-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.monthlyagg" href="#ClimateBase.monthlyagg"><code>ClimateBase.monthlyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">monthlyagg(A::ClimArray, f = mean) -&gt; B</code></pre><p>Create a new array where the temporal daily information has been aggregated to months using the function <code>f</code>. By convention, the dates of the new array always have day number of <code>15</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/temporal.jl#L278-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.yearlyagg" href="#ClimateBase.yearlyagg"><code>ClimateBase.yearlyagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yearlyagg(A::ClimArray, f = mean) -&gt; B</code></pre><p>Create a new array where the temporal information has been aggregated to years using the function <code>f</code>. By convention, the dates of the new array always have month and day number of <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/temporal.jl#L293-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.temporalrange" href="#ClimateBase.temporalrange"><code>ClimateBase.temporalrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">temporalrange(t::AbstractVector{&lt;:TimeType}}, f = Dates.month) → r</code></pre><p>Return a vector of ranges so that each range of indices are values of <code>t</code> that belong in either the same month, year, or day, depending on <code>f</code>. <code>f</code> can take the values: <code>Dates.year, Dates.month, Dates.day</code> (functions).</p><p>Used in e.g. <a href="#ClimateBase.monthlyagg"><code>monthlyagg</code></a> or <a href="#ClimateBase.yearlyagg"><code>yearlyagg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/temporal.jl#L318-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.maxyearspan" href="#ClimateBase.maxyearspan"><code>ClimateBase.maxyearspan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maxyearspan(A::ClimArray) = maxyearspan(dims(A, Time))
maxyearspan(t::Vector{&lt;:DateTime}) → i</code></pre><p>Find the maximum index <code>i</code> of <code>t</code> so that <code>t[1:i]</code> covers exact(*) multiples of years.</p><p>(*) For monthly spaced data <code>i</code> is a multiple of <code>12</code> while for daily data we find the largest possible multiple of <code>DAYS_IN_YEAR = 365.26</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/temporal.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.temporal_sampling" href="#ClimateBase.temporal_sampling"><code>ClimateBase.temporal_sampling</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">temporal_sampling(x) → symbol</code></pre><p>Return the temporal sampling type of <code>x</code>, which is either an array of <code>Date</code>s or a dimensional array (with <code>Time</code> dimension).</p><p>Possible return values are:</p><ul><li><code>:yearly</code>, where all dates have the same month+day, but different year.</li><li><code>:monthly</code>, where all dates have the same day, but different month.</li><li><code>:daily</code>, where the temporal difference between dates are exactly 1 day.</li><li><code>:hourly</code>, where the temporal difference between entries is exactly 1 hour.</li><li><code>:other</code>, which means that <code>x</code> doesn&#39;t fall to any of the above categories.</li></ul><p>For vector input, only the first 3 entries of the temporal information are used to deduce the sampling (while for ranges, checking the step is enough).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/temporal.jl#L97-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.time_in_days" href="#ClimateBase.time_in_days"><code>ClimateBase.time_in_days</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_in_days(t::AbstractArray{&lt;:TimeType}, T = Float32)</code></pre><p>Convert a given date time array into measurement units of days: a real-valued array which counts time in days, always increasing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/temporal.jl#L78-L82">source</a></section></article><h2 id="Spatial"><a class="docs-heading-anchor" href="#Spatial">Spatial</a><a id="Spatial-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial" title="Permalink"></a></h2><h3 id="Types-of-spatial-coordinates"><a class="docs-heading-anchor" href="#Types-of-spatial-coordinates">Types of spatial coordinates</a><a id="Types-of-spatial-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-spatial-coordinates" title="Permalink"></a></h3><p>Most of the time the spatial information of your data is in the form of a Longitude × Latitude grid. This is simply achieved via the existence of two dimensions (<code>Lon, Lat</code>) in your dimensional data array. Height, although representing physical space as well, is not considered part of the &quot;spatial dimensions&quot;, and is treated as any other additional dimension. This type of space is called <code>Grid</code>. It is assumed throughout that longitude and latitude are measured in <strong>degrees</strong>.</p><p>Another type of spatial coordinates is supported, and that is of <strong>equal-area</strong>, called <code>EqArea</code>. There, the spatial dimension is instead given by a single <code>Vector</code> of coordinate locations, i.e. 2-element <code>SVector(longitude, latitude)</code>. The dimension of this vector is <code>Coord</code>. Each point in this vector corresponds to a polygon (typically triangle or trapezoid) that covers equal amount of spatial area as any other point. The actual limits of each polygon are not included in the dimension. Typical examples of such equal area grids are reduced (or thinned) Gaussian grids or icosahedral-based grids.</p><p>Within ClimateBase.jl aims to work with either type of spatial coordinate system. Therefore, physically inspired averaging functions, like <a href="#ClimateBase.spacemean"><code>spacemean</code></a> or <a href="#ClimateBase.zonalmean"><code>zonalmean</code></a>, work for both types of spatial coordinates. In addition, the function <code>spatialidxs</code> returns an iterator over the spatial coordinates of the data, and works for both types (grid or equal-area):</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spatialidxs" href="#ClimateBase.spatialidxs"><code>ClimateBase.spatialidxs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spatialidxs(A::ClimArray) → idxs</code></pre><p>Return an iterable that can be used to access all spatial points of <code>A</code> with the syntax</p><pre><code class="language-julia">idxs = spatialidxs(A)
for i in idxs
    slice_at_give_space_point = A[i...]
end</code></pre><p>Works for standard grid as well as equal area (<code>...</code> necessary because <code>i</code> is a <code>Tuple</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/spatial.jl#L12-L22">source</a></section></article><h3 id="Spatial-aggregation"><a class="docs-heading-anchor" href="#Spatial-aggregation">Spatial aggregation</a><a id="Spatial-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-aggregation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.zonalmean" href="#ClimateBase.zonalmean"><code>ClimateBase.zonalmean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">zonalmean(A::ClimArray)</code></pre><p>Return the zonal mean of <code>A</code>. Optionally do the mean for the data in range <code>r</code> of the longitude (<code>r</code> is fed into the dimension so it can be A range or an arbitrary selector).</p><p>Works for both grid and equal area space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/spatial.jl#L81-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.latmean" href="#ClimateBase.latmean"><code>ClimateBase.latmean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">latmean(A::ClimArray [, r])</code></pre><p>Return the latitude-mean <code>A</code> (mean across dimension <code>Lat</code>). Optionally do the mean for the data in range <code>r</code> of that dimension.</p><p>This function properly weights the mean by the cosine of the latitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/spatial.jl#L140-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spacemean" href="#ClimateBase.spacemean"><code>ClimateBase.spacemean</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spacemean(A::ClimArray [, w]) = spaceagg(mean, A, w)</code></pre><p>Average given <code>A</code> over its spatial coordinates. Optionally provide statistical weights in <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/spatial.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.spaceagg" href="#ClimateBase.spaceagg"><code>ClimateBase.spaceagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spaceagg(f, A::ClimArray, w = nothing)</code></pre><p>Aggregate <code>A</code> using function <code>f</code> (e.g. <code>mean</code>) over all available space (i.e. longitude and latitude) of <code>A</code>, weighting every part of <code>A</code> by its spatial area. The function works for grid as well as equal area space.</p><p><code>w</code> can be extra weights, to weight each spatial point with. <code>w</code> can either be just an <code>AbDimArray</code> with same space as <code>A</code>, or of exactly same shape as <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/spatial.jl#L174-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.hemispheric_means" href="#ClimateBase.hemispheric_means"><code>ClimateBase.hemispheric_means</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hemispheric_means(A) → nh, sh</code></pre><p>Return the (proper) averages of <code>A</code> over the northern and southern hemispheres. Notice that this function explicitly does both zonal as well as meridional averaging. Use <a href="#ClimateBase.hemispheric_functions"><code>hemispheric_functions</code></a> to just split <code>A</code> into two hemispheres.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/spatial.jl#L277-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.hemispheric_functions" href="#ClimateBase.hemispheric_functions"><code>ClimateBase.hemispheric_functions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hemispheric_functions(A::ClimArray) → north, south</code></pre><p>Return two arrays <code>north, south</code>, by splitting <code>A</code> to its northern and southern hemispheres, appropriately translating the latitudes of <code>south</code> so that both arrays have the same latitudinal dimension (and thus can be compared and do opperations between them).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/spatial.jl#L241-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.lonlatfirst" href="#ClimateBase.lonlatfirst"><code>ClimateBase.lonlatfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lonlatfirst(A::ClimArray, args...) → B</code></pre><p>Permute the dimensions of <code>A</code> to make a new array <code>B</code> that has first dimension longitude, second dimension latitude, with the remaining dimensions of <code>A</code> following (useful for most plotting functions). Optional extra dimensions can be given as <code>args...</code>, specifying a specific order for the remaining dimensions.</p><p>Example:</p><pre><code class="language-julia">B = lonlatfirst(A)
C = lonlatfirst(A, Time)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/physical_dimensions/spatial.jl#L34-L46">source</a></section></article><h2 id="General-aggregation"><a class="docs-heading-anchor" href="#General-aggregation">General aggregation</a><a id="General-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#General-aggregation" title="Permalink"></a></h2><p>The physical averages of the previous section are done by taking advantage of a general aggregation syntax, which works with any aggregating function like <code>mean, sum, std</code>, etc.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.dropagg" href="#ClimateBase.dropagg"><code>ClimateBase.dropagg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dropagg(f, A, dims)</code></pre><p>Apply aggregating function <code>f</code> (e.g. <code>sum</code>) on array <code>A</code> across dimension(s) <code>dims</code> and drop the corresponding dimension(s) from the result (Julia inherently keeps singleton dimensions).</p><p>If <code>A</code> is one dimensional, <code>dropagg</code> will return the single number of applying <code>f(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/core/aggregation.jl#L23-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.collapse" href="#ClimateBase.collapse"><code>ClimateBase.collapse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collapse(f, A, dim)</code></pre><p>Reduce <code>A</code> towards dimension <code>dim</code> using the collapsing function <code>f</code> (e.g. <code>mean</code>). This means that <code>f</code> is applied across all other dimensions of <code>A</code>, each of which are subsequently dropped, leaving only the collapsed result of <code>A</code> vs. the remaining dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/core/aggregation.jl#L35-L40">source</a></section></article><h2 id="Timeseries-Analysis"><a class="docs-heading-anchor" href="#Timeseries-Analysis">Timeseries Analysis</a><a id="Timeseries-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Timeseries-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.sinusoidal_continuation" href="#ClimateBase.sinusoidal_continuation"><code>ClimateBase.sinusoidal_continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sinusoidal_continuation(T::ClimArray, fs = [1, 2]; Tmin = -Inf, Tmax = Inf)</code></pre><p>Fill-in the missing values of spatiotemporal field <code>T</code>, by fitting sinusoidals to the non-missing values, and then using the fitted sinusoidals for the missing values.</p><p>Frequencies are given per year (frequency 2 means 1/2 of a year).</p><p><code>Tmin, Tmax</code> limits are used to clamp the result into this range (no clamping in the default case).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/tsa/continuation.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.seasonal_decomposition" href="#ClimateBase.seasonal_decomposition"><code>ClimateBase.seasonal_decomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seasonal_decomposition(A::ClimArray, fs = [1, 2]) → seasonal, residual</code></pre><p>Decompose <code>A</code> into a seasonal and residual components, where the seasonal contains the periodic parts of <code>A</code>, with frequencies given in <code>fs</code>, and residual contains what&#39;s left.</p><p><code>fs</code> is measured in 1/year. This function works even for non-equispaced time axis (e.g. monthly averages) and uses LPVSpectral.jl and SignalDecomposition.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/tsa/decomposition.jl#L5-L12">source</a></section></article><h2 id="Climate-quantities"><a class="docs-heading-anchor" href="#Climate-quantities">Climate quantities</a><a id="Climate-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Climate-quantities" title="Permalink"></a></h2><p>Functions that calculate climate-related quantities.</p><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.insolation" href="#ClimateBase.insolation"><code>ClimateBase.insolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insolation(t, ϕ; kwargs...)</code></pre><p>Calculate daily averaged insolation in W/m² at given time and latitude <code>t, φ</code>. <code>φ</code> is given in <strong>degrees</strong>, and <code>t</code> in <strong>days</strong> (real number or date).</p><p>Keywords:</p><pre><code class="language-none">Ya = DAYS_IN_YEAR # = 365.26 # days
t_VE = 76.0 # days of vernal equinox
S_0 = 1362.0 # W/m^2
γ=23.44
ϖ=282.95
e=0.017 # eccentricity</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/climate/solar.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.surface_atmosphere_contributions" href="#ClimateBase.surface_atmosphere_contributions"><code>ClimateBase.surface_atmosphere_contributions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">surface_atmosphere_contributions(I, F_toa_⬆, F_s_⬆, F_s_⬇) → α_ATM, α_SFC</code></pre><p>Calculate the atmospheric and surface <strong>contributions</strong> of the planetary albedo, so that the TOA albedo is <code>α = α_ATM + α_SFC</code>, using the simple 1-layer radiative transfer model by Donohoe &amp; Battisti (2011) or G. Stephens (2015). Stephens&#39; formulas are incorrect and I have corrected them!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/climate/albedo.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ClimateBase.total_toa_albedo" href="#ClimateBase.total_toa_albedo"><code>ClimateBase.total_toa_albedo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">total_toa_albedo(a, s, t) = a + s*t^2/(1-a*s)</code></pre><p>Combine given atmosphere albedo <code>a</code>, surface albedo <code>s</code> and atmosphere transmittance <code>t</code> into a total top-of-the-atmosphere albedo <code>α</code> according to the model of Donohoe &amp; Battisti (2011).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaClimate/ClimateBase.jl/blob/4ae56f45fe60be44396d450ecb54ed4532cad28f/src/climate/albedo.jl#L30-L34">source</a></section></article><h2 id="Crash-course-to-DimensionalData.jl"><a class="docs-heading-anchor" href="#Crash-course-to-DimensionalData.jl">Crash-course to DimensionalData.jl</a><a id="Crash-course-to-DimensionalData.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Crash-course-to-DimensionalData.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DimensionalData" href="#DimensionalData"><code>DimensionalData</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>DimensionalData</strong></p><p><a href="https://rafaqz.github.io/DimensionalData.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://rafaqz.github.io/DimensionalData.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt/></a> <a href="https://travis-ci.com/rafaqz/DimensionalData.jl"><img src="https://travis-ci.com/rafaqz/DimensionalData.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://codecov.io/gh/rafaqz/DimensionalData.jl"><img src="https://codecov.io/gh/rafaqz/DimensionalData.jl/branch/master/graph/badge.svg" alt="Codecov"/></a> <a href="https://github.com/JuliaTesting/Aqua.jl"><img src="https://img.shields.io/badge/Aqua.jl-%F0%9F%8C%A2-aqua.svg" alt="Aqua.jl Quality Assurance"/></a></p><p>DimensionalData.jl provides tools and abstractions for working with datasets that have named dimensions. It&#39;s a pluggable, generalised version of <a href="https://github.com/JuliaArrays/AxisArrays.jl">AxisArrays.jl</a> with a cleaner syntax, and additional functionality found in NamedDims.jl. It has similar goals to pythons <a href="http://xarray.pydata.org/en/stable/">xarray</a>, and is primarily written for use with spatial data in <a href="https://github.com/rafaqz/GeoData.jl">GeoData.jl</a>.</p><p><strong>Dimensions</strong></p><p>Dimensions are just wrapper types. They store the dimension index and define details about the grid and other metadata, and are also used to index into the array, wrapping a value or a <code>Selector</code>. <code>X</code>, <code>Y</code>, <code>Z</code> and <code>Ti</code> are the exported defaults.</p><p>A generalised <code>Dim</code> type is available to use arbitrary symbols to name dimensions. Custom dimensions can be defined using the <code>@dim</code> macro.</p><p>We can use dim wrappers for indexing, so that the dimension order in the underlying array does not need to be known:</p><pre><code class="language-julia">julia&gt; using DimensionalData

julia&gt; A = DimArray(rand(40, 50), (X, Y));

julia&gt; A[Y(1), X(1:10)]
DimArray with dimensions:
 X: 1:10 (NoIndex)
and referenced dimensions:
 Y: 1 (NoIndex)
and data: 10-element Array{Float64,1}
[0.515774, 0.575247, 0.429075, 0.234041, 0.4484, 0.302562, 0.911098, 0.541537, 0.267234, 0.370663]</code></pre><p>And this has no runtime cost:</p><pre><code class="language-julia">julia&gt; A = DimArray(rand(40, 50), (X, Y));

julia&gt; @btime $A[X(1), Y(2)]
  2.092 ns (0 allocations: 0 bytes)
0.27317596504655417

julia&gt; @btime parent($A)[1, 2]
  2.092 ns (0 allocations: 0 bytes)
0.27317596504655417</code></pre><p>Dims can be used for indexing and views without knowing dimension order:</p><pre><code class="language-julia">julia&gt; A[X(10)]
DimArray with dimensions:
 Y (type Y): Base.OneTo(50) (NoIndex)
and referenced dimensions:
 X (type X): 10 (NoIndex)
and data: 50-element Array{Float64,1}
[0.0850249, 0.313408, 0.0762157, 0.549103, 0.297763, 0.309075, 0.854535, 0.659537, 0.392969, 0.89998  …  0.63791, 0.875881, 0.437688, 0.925918, 0.291636, 0.358024, 0.692283, 0.606932, 0.629122, 0.284592]

julia&gt; view(A, Y(30:40), X(1:5))
DimArray with dimensions:
 X (type X): 1:5 (NoIndex)
 Y (type Y): 30:40 (NoIndex)
and data: 5×11 view(::Array{Float64,2}, 1:5, 30:40) with eltype Float64
 0.508793   0.721117  0.558849  …  0.505518   0.532322
 0.869126   0.754219  0.328315     0.0148934  0.778308
 0.0596468  0.458492  0.250458     0.980508   0.524938
 0.446838   0.659638  0.632399     0.33478    0.549402
 0.292962   0.995038  0.26026      0.526124   0.589176</code></pre><p>And for indicating dimensions to reduce or permute in julia <code>Base</code> and <code>Statistics</code> functions that have dims arguments:</p><pre><code class="language-julia">julia&gt; using Statistics

julia&gt; A = DimArray(rand(3, 4, 5), (X, Y, Ti));

julia&gt; mean(A, dims=Ti)
DimArray with dimensions:
 X (type X): Base.OneTo(3) (NoIndex)
 Y (type Y): Base.OneTo(4) (NoIndex)
 Time (type Ti): 1 (NoIndex)
and data: 3×4×1 Array{Float64,3}
[:, :, 1]
 0.495295  0.650432  0.787521  0.502066
 0.576573  0.568132  0.770812  0.504983
 0.39432   0.5919    0.498638  0.337065
[and 0 more slices...]

julia&gt; permutedims(A, [Ti, Y, X])
DimArray with dimensions:
 Time (type Ti): Base.OneTo(5) (NoIndex)
 Y (type Y): Base.OneTo(4) (NoIndex)
 X (type X): Base.OneTo(3) (NoIndex)
and data: 5×4×3 Array{Float64,3}
[:, :, 1]
 0.401374  0.469474  0.999326  0.265688
 0.439387  0.57274   0.493883  0.88678
 0.425845  0.617372  0.998552  0.650999
 0.852777  0.954702  0.928367  0.0045136
 0.357095  0.637873  0.517476  0.702351
[and 2 more slices...]</code></pre><p>You can also use symbols to create <code>Dim{X}</code> dimensions:</p><pre><code class="language-julia">julia&gt; A = DimArray(rand(10, 20, 30), (:a, :b, :c));

julia&gt; A[a=2:5, c=9]

DimArray with dimensions:
 Dim{:a}: 2:5 (NoIndex)
 Dim{:b}: Base.OneTo(20) (NoIndex)
and referenced dimensions:
 Dim{:c}: 9 (NoIndex)
and data: 4×20 Array{Float64,2}
 0.868237   0.528297   0.32389   …  0.89322   0.6776    0.604891
 0.635544   0.0526766  0.965727     0.50829   0.661853  0.410173
 0.732377   0.990363   0.728461     0.610426  0.283663  0.00224321
 0.0849853  0.554705   0.594263     0.217618  0.198165  0.661853</code></pre><p><strong>Selectors</strong></p><p>Selectors find indices in the dimension based on values <code>At</code>, <code>Near</code>, or <code>Between</code> the index value(s). They can be used in <code>getindex</code>, <code>setindex!</code> and <code>view</code> to select indices matching the passed in value(s)</p><ul><li><code>At(x)</code>: get indices exactly matching the passed in value(s)</li><li><code>Near(x)</code>: get the closest indices to the passed in value(s)</li><li><code>Where(f::Function)</code>: filter the array axis by a function of dimension index values.</li><li><code>Between(a, b)</code>: get all indices between two values (inclusive)</li><li><code>Contains(x)</code>: get indices where the value x falls in the interval. Only used for <code>Sampled</code> <code>Intervals</code>, for <code>Points</code> us <code>At</code>.</li></ul><p>We can use selectors with dim wrappers:</p><pre><code class="language-julia">using Dates, DimensionalData
timespan = DateTime(2001,1):Month(1):DateTime(2001,12)
A = DimArray(rand(12,10), (Ti(timespan), X(10:10:100)))

julia&gt; A[X(Near(35)), Ti(At(DateTime(2001,5)))]
0.658404535807791

julia&gt; A[Near(DateTime(2001, 5, 4)), Between(20, 50)]
DimArray with dimensions:
 X: 20:10:50
and referenced dimensions:
 Time (type Ti): 2001-05-01T00:00:00
and data: 4-element Array{Float64,1}
[0.456175, 0.737336, 0.658405, 0.520152]</code></pre><p>Without dim wrappers selectors must be in the right order:</p><pre><code class="language-julia">using Unitful

julia&gt; A = DimArray(rand(10, 20), (X((1:10:100)u&quot;m&quot;), Ti((1:5:100)u&quot;s&quot;)))

julia&gt; A[Between(10.5u&quot;m&quot;, 50.5u&quot;m&quot;), Near(23u&quot;s&quot;)]
DimArray with dimensions:
 X: (11:10:41) m (Sampled: Ordered Regular Points)
and referenced dimensions:
 Time (type Ti): 21 s (Sampled: Ordered Regular Points)
and data: 4-element Array{Float64,1}
[0.819172, 0.418113, 0.461722, 0.379877]</code></pre><p>For values other than <code>Int</code>/<code>AbstractArray</code>/<code>Colon</code> (which are set aside for regular indexing) the <code>At</code> selector is assumed, and can be dropped completely:</p><pre><code class="language-julia">julia&gt; A = DimArray(rand(3, 3), (X(Val((:a, :b, :c))), Y([25.6, 25.7, 25.8])));

julia&gt; A[:b, 25.8]
0.61839141062599</code></pre><p><strong>Compile-time selectors</strong></p><p>Using all <code>Val</code> indexes (only recommended for small arrays) you can index with named dimensions <code>At</code> arbitrary values with no runtime cost:</p><pre><code class="language-julia">julia&gt; A = DimArray(rand(3, 3), (cat=Val((:a, :b, :c)),
                                 val=Val((5.0, 6.0, 7.0))));

julia&gt; @btime $A[:a, 7.0]
  2.094 ns (0 allocations: 0 bytes)
0.25620608873275397

julia&gt; @btime $A[cat=:a, val=7.0]
  2.091 ns (0 allocations: 0 bytes)
0.25620608873275397</code></pre><p><strong>Methods where dims can be used containing indices or Selectors</strong></p><p><code>getindex</code>, <code>setindex!</code> <code>view</code></p><p><strong>Methods where dims can be used</strong></p><ul><li><code>size</code>, <code>axes</code>, <code>firstindex</code>, <code>lastindex</code></li><li><code>cat</code></li><li><code>reverse</code></li><li><code>dropdims</code></li><li><code>reduce</code>, <code>mapreduce</code></li><li><code>sum</code>, <code>prod</code>, <code>maximum</code>, <code>minimum</code>,</li><li><code>mean</code>, <code>median</code>, <code>extrema</code>, <code>std</code>, <code>var</code>, <code>cor</code>, <code>cov</code></li><li><code>permutedims</code>, <code>adjoint</code>, <code>transpose</code>, <code>Transpose</code></li><li><code>mapslices</code>, <code>eachslice</code></li><li><code>fill</code></li></ul><p><strong>Warnings</strong></p><p>Indexing with unordered or reverse order arrays has undefined behaviour. It will trash the dimension index, break <code>searchsorted</code> and nothing will make sense any more. So do it at you own risk. However, indexing with sorted vectors of Int can be useful. So it&#39;s allowed. But it will still do strange things to your interval sizes if the dimension span is <code>Irregular</code>.</p><p><strong>Alternate Packages</strong></p><p>There are a lot of similar Julia packages in this space. AxisArrays.jl, NamedDims.jl, NamedArrays.jl are registered alternative that each cover some of the functionality provided by DimensionalData.jl. DimensionalData.jl should be able to replicate most of their syntax and functionality.</p><p><a href="https://github.com/mcabbott/AxisKeys.jl">AxisKeys.jl</a> and <a href="https://github.com/Tokazama/AbstractIndices.jl">AbstractIndices.jl</a> are some other interesting developments. For more detail on why there are so many similar options and where things are headed, read this <a href="https://github.com/JuliaCollections/AxisArraysFuture/issues/1">thread</a>.</p></div></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 13 November 2020 14:07">Friday 13 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
